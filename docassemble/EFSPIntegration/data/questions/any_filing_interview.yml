---
modules:
  - .efm_client
---
imports:
  - functools
---
include:
  - login_qs.yml
  - efiling_integration.yml
  - docassemble.AssemblyLine:al_package.yml
  - case_search.yml
  - codes_helper.yml
---
code: |
  user_wants_efile = True # This interview is always for e-filing
---
code: |
  jurisdiction_id = 'illinois'
---
code: |
  user_registration_choices = [
    ('INDIVIDUAL', 'Pro Se user'),
    ('FIRM_ADMINISTRATOR', 'Administrator of a new firm'),
    ('FIRM_ADMIN_NEW_MEMBER', 'New member of current firm')
  ]
---
mandatory: True
code: |
  welcome
  tyler_login 
  trial_court
  can_check_efile
  if not is_initial_filing and not case_was_found and not can_file_non_indexed_case:
    failed_case_search

  if is_nonindexed_filing:
      docket_number = non_indexed_docket_number
  if needs_all_info:
    tyler_case_category = case_category_map.get(case_category,{}).get('code')
    tyler_case_type = case_type_map.get(case_type,{}).get('code')
    if case_subtype_options:
      tyler_case_subtype = case_subtype_map.get(case_subtype).get('code')
    tyler_filing_attorney
    user_ask_role
    user_started_case
  else:
    if case_was_found:
      load_existing_case_defaults
      previous_case_id = found_case.tracking_id 
      user_started_case
      is_adding_new_parties

  users.gather()
  other_parties.gather()
  existing_parties_new_atts.gather(complete_attribute='attorney_ids')
  attorney_ids
  party_to_attorneys
  all_case_parties
  if needs_all_info or showifdef('users[0].is_form_filler', False):
    lead_contact = users[0]
  else:
    lead_contact.name.first
  
  if needs_all_info:
    reconsider('missing_required_party_types')
    if missing_required_party_types:
      party_review_screen
  
  lead_doc.completed
  append_lead_doc
  al_court_bundle.auto_gather=True
  al_court_bundle.gather()
  
  contacts_to_attach.gather()
  service_contacts.gather()
  cross_references.gather()
  al_court_bundle.as_pdf()
  
  if needs_all_info:
    lead_contact.email
  
  if full_court_info.data.get('allowreturndate'):
    return_date
    show_allowed_return_date

  if is_initial_filing and len(users) == 1:
    explain_user_paying

  tyler_payment_id

  if can_check_efile:
    if needs_all_info:
      lead_contact.email
    #TODO(qs): if not a waiver account...
    ready_to_efile
    if fees_resp.is_ok():
      review_fees
    else:
      bad_fees

  show_disclaimers
  efile
  summary_page
---
code: |
  proxy_conn = ProxyConnection(credentials_code_block='tyler_login')
---
features:
  question back button: True
  navigation back button: False
---
objects:
  - lead_contact: ALIndividual
---
objects:
  - users: ALPeopleList.using(there_are_any=needs_all_info or is_adding_new_parties, complete_attribute='complete')
  - other_parties: ALPeopleList.using(complete_attribute='complete') # NOTE that there can be filing types with no opposing party, such as adoption
---
objects:
  - existing_parties_new_atts: DAList.using(object_type=DAObject)
---
objects:
  - lead_doc: ALExhibitDocument.using(title="Lead Filing Doc", filename="lead_filing_doc", include_table_of_contents=False, include_exhibit_cover_pages=False)
---
code: |
  al_court_bundle.clear()
  al_court_bundle.append(lead_doc)
  
  append_lead_doc = True
---
generic object: ALDocument
code: |
  # Every filing type needs an associated document
  x.exhibits.has_exhibits = True
---
generic object: ALDocument
code: |
  # You can only have exactly one exhibit per ALExhibitDocument
  # for this filing interview
  x.exhibits.has_exhibits = True
  x.exhibits.ask_number = True
  x.exhibits.target_number = 1
---
event: failed_case_search
question: |
  Could not find an existing case to file into
subquestion: |
  Please try again.
buttons:
  - restart
---
generic object: ALDocument
id: any exhibits
question: |
  Please upload your documents
subquestion: |
  You will have a chance to upload multiple documents. 
  You can also add additional pages to this document.
fields:
  - Filing Type: x.filing_type
    datatype: dropdown
    code: |
      sorted(filing_type_options, key=lambda option: option[1])
  - label: |
      Description
      % if not filing_description_datafield.get('isrequired'):
      (optional)
      % endif
    field: x.filing_description
    datatype: text
    required: |
      filing_description_datafield.get('isrequired', False)   
  - Reference Number (optional): x.reference_number
    datatype: text
    required: False
  - Document: x.exhibits[0].pages
    datatype: files
    maximum image size: 1024
    image upload type: jpeg        
    accept: |
      "image/png, image/jpeg, .doc,.docx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/pdf,.pdf"
  - Add a courtesy email: x.has_courtesy_copies
    datatype: yesno
  - Courtesy emails (one per line): x.courtesy_copies_raw
    datatype: area  
    show if: x.has_courtesy_copies
validation code: |
  if sum(exhibit.size_in_bytes() for exhibit in x.exhibits[0].pages) > (15 * 1024 * 1024):
    validation_error("Upload a file smaller than 15 MB.")
  try:
    pdf_concatenate(x.exhibits[0].pages)
  except:
    validation_error("Unable to convert this file. Please upload a new one.", field="x.exhibits[0].pages")
  x.exhibits[0].pages.reset_gathered()  # docassemble sets this attribute but we want to force gathering additional pages

  if x.has_courtesy_copies:
    x.courtesy_copies = x.courtesy_copies_raw.splitlines()
    for copy in x.courtesy_copies:
      if not '@' in copy:
        validation_error("Enter a valid email address.", field="x.courtesy_copies_raw")
        break     
---
generic object: ALExhibitDocument
code: |
  x.exhibits[i].title = x.filing_description if x.filing_description else filing_type_map.get(x.filing_type,{}).get('name')
---
generic object: ALExhibitDocument
code: |
  x.filename = space_to_underscore(x.exhibits[0].title)
---
id: another exhibit
question: |
  You have ${ al_court_bundle.number_gathered() } document(s) so far. Do you have another document
  you want to upload?
#subquestion: |
#  ${ collapse_template(x.in_progress_exhibits) }
field: al_court_bundle.there_is_another
buttons:
  - Finished adding documents: False
  - Add another document: True
---
generic object: ALExhibitList
template: x.in_progress_exhibits
subject: |
  Preview your documents so far
content: |
  ${ x.rearrange_exhibits_table }
---
generic object: ALExhibitList
table: x.rearrange_exhibits_table
rows: x
allow reordering: True
delete buttons: True
columns:
  - ${ al_exhibit_title_label }: |
      row_item.title
  - ${ al_exhibit_preview_label }: |
      row_item.pages.show(width="50%")
  - ${ al_exhibit_total_pages_label }: |
      row_item.pages.num_pages()
edit:
  - rearrange_pages  
---
objects:
  - contacts_to_attach: DAList.using(object_type=DAObject, complete_attribute='complete')
  - service_contacts: DAList.using(object_type=DAObject, complete_attribute='complete')
---
objects:
  - cross_references: DADict.using(there_are_any=len(cross_ref_types))
---
generic object: ALExhibitDocument
code: |
  x.enabled = True
---
objects:
  - al_court_bundle: ALDocumentBundle.using(filename="full_bundle.pdf", title="All forms to submit to the court", object_type=ALExhibitDocument, complete_attribute = 'completed', gathered=False, auto_gather=True, there_are_any=True)
---
code: |
  if is_initial_filing:
    al_form_type = 'starts_case'
  else:
    al_form_type = 'existing_case'
---
id: review_fees
question: |
  Review filing fees
subquestion: |
  Your payment account will be charged the following fees:
  
  % if has_fees:
  ${ fees_table }
  
  **Total: ${ currency(fee_total(fees_resp)) }**
  % else:
  There are no fees associated with this filing.
  % endif  
fields:
  - no label: review_fees
    datatype: checkboxes
    choices:
      - ${ 'I agree to pay the listed fees of ' + str(currency(fee_total(fees_resp))) if has_fees else 'No fees' }: agrees_to_pay_fees
    minlength: 1
    validation messages:
      minlength: |
        You must agree to pay the fees listed above.
---
id: bad fees
event: bad_fees
question: |
  Something went wrong
subquestion: |
  Sorry, something went wrong when trying to figure out what fees you might have to pay.
 
  More details: ${ debug_display(fees_resp) }
---
depends on:
  - fees_resp
code: |
  has_fees = fee_total(fees_resp) and float(fee_total(fees_resp)) > 0
---
code: |
  fees_resp = proxy_conn.calculate_filing_fees(jurisdiction_id, court_id, al_court_bundle)
  if not fees_resp.is_ok():
    log(f'fees not ok! {fees_resp}')
---
depends on:
  - fees_resp
table: fees_table
rows: |
  [fee for fee in fees_resp.data.get('allowanceCharge',[]) if fee.get('chargeIndicator',{}).get('value')]
columns:
  - Reason: |
      row_item.get('allowanceChargeReason',{}).get('value')
  - Amount: |
      currency(row_item.get('amount',{}).get('value',0))
---
code: |
  def fee_total(my_resp):
    if my_resp.data:
      return my_resp.data.get('feesCalculationAmount',{}).get('value')
---
generic object: ALIndividual
code: |
  str(x.name)
  x.party_type = party_type_map.get(x.party_type_code).get('code')
  x.is_new = True
  x.complete = True
---
code: |
  users[i].is_form_filler
  str(users[i].name)
  users[i].party_type = party_type_map.get(users[i].party_type_code).get('code')
  users[i].attorney_ids
  users[i].is_new = True
  users[i].complete = True
---
code: |
  no_missing_required_party_types_temp = True
  for p_type in party_type_map.values():
    if p_type.get('isrequired'):
      no_missing_required_party_types_temp &= (
        any(filter(lambda p: p.party_type_code == p_type.get('code'), users)) or
        any(filter(lambda p: p.party_type_code == p_type.get('code'), other_parties))
        )
  missing_required_party_types = not no_missing_required_party_types_temp
  del no_missing_required_party_types_temp
---
generic object: ALPeopleList
table: x.review_type_table
rows: x
columns:
  - Name: |
      row_item.name.full()
  - Type: |
      party_type_map.get(row_item.party_type_code,{}).get('name')
edit:
  - party_type_code  
---
sets:
  - lead_contact.name.first
question: |
  Who should be contacted about this filing?
fields:
  - email: lead_contact.email
    datatype: email
  - code: |
      lead_contact.name_fields()
---
id: review parties
continue button field: party_review_screen
question: |
  Review parties
subquestion: |
  % if missing_required_party_types:
  ### Warning: you are missing a required party type!
  
  This case requires that you have at least one:
  
  % for p_type in party_type_map.values():
  * ${ p_type.get('name') }
  % endfor
  
  % endif
  #### Parties on your side of the case
  ${ users.review_type_table }
  ${ users.add_action() }
  
  #### Other parties
  ${ other_parties.review_type_table }
  ${ other_parties.add_action() }
---
code: |
  return_date_resp = proxy_conn.get_return_date(court_id, user_return_date.date(), al_court_bundle)
  if return_date_resp.is_ok() and isinstance(return_date_resp.data, dict) and 'value' in return_date_resp.data:
    return_date_obj = tyler_timestamp_to_datetime(return_date_resp.data.get('value'))
    return_date = return_date_obj.date().isoformat()
  else:
    return_date_obj = None
    return_date = ''
---
generic object: ALDocument
code: |
  x.filing_type
  x.filing_description
  x.reference_number
  x.tyler_filing_type 
  x.document_type
  x.motion_type
  x.filing_component
  # Needed specifically for ALExhibitDocuments, not the default
  if x.exhibits.has_exhibits:
    x.as_pdf()
  x.filing_parties
  x.filing_action
  x.optional_services.gather(complete_attribute='complete')  
  x.completed =True
---
id: Additional parties
question: |
  Are you adding any additional parties to this filing?
yesno: is_adding_new_parties
---
id: make a filing
question: |
  Make a Filing
subquestion: |
  Welcome! You can make any type of filing in an Illinois court, to a pre-existing or new case, in this interview.
continue button field: welcome
---
id: return date
question: |
  Closest available return date
subquestion: |
  % if return_date_resp.is_ok() and 'value' in return_date_resp.data:
  The closest available return date is:
  
  ${ return_date_obj }
  
  You will have to contact the court to get a different return date.
  
  % else:
  Something went wrong retrieving a return date
  
  ${ debug_display(return_date_resp) }
  % endif
continue button field: show_allowed_return_date
---
generic object: ALDocument
code: |
  contacts_to_attach.gather()
  if not service_contacts:
    x.filing_action = 'efile'
---
id: initial filing
question: |
  Are you filing into a new case or an existing one?
field: filing_interview_initial_or_existing
choices:
  - I am starting a new case: initial_document
  - I am adding a document to an existing case: existing_case
---
code: |
  is_initial_filing = filing_interview_initial_or_existing == 'initial_document'
---
code: |
  is_nonindexed_filing = not is_initial_filing and (not case_was_found and can_file_non_indexed_case)
---
code: |
  needs_all_info = is_initial_filing or is_nonindexed_filing
---
code: |
  selected_existing_case = found_case
---
code: |
  if selected_existing_case:
    if selected_existing_case.category:
      case_category = selected_existing_case.category
    if selected_existing_case.case_type:
      case_type = selected_existing_case.case_type
    # TODO(brycew): get party info from existing case to select filing parties 
    existing_case_parties = None
  load_existing_case_defaults = True
---
generic object: ALIndividual
question: |
  Adding Attorneys for ${ x }
subquestion: |
  What attorneys are you adding?
fields:
  - Attorneys: x.attorney_adding_opts
    datatype: multiselect
    required: False
    code: |
      tyler_filing_attorney_options
---
question: |
  Are there any more attorneys you'd like to attach to existing contacts?
fields:
  - no label: existing_parties_new_atts.there_is_another
    datatype: yesnoradio
---
id: any attorneys to existing parties
question: |
  Are there any attorneys you'd like to attach to existing contacts?
fields:
  - no label: existing_parties_new_atts.there_are_any
    datatype: yesnoradio
---
code: |
  if is_initial_filing:
    existing_parties_new_atts.there_are_any = False
---
question: |
  Add attorneys to existing users
fields: 
  - To party: existing_parties_new_atts[i].existing_party
    datatype: select
    code: |
      [(part.tyler_id, str(part.name)) for part in found_case.participants if part.tyler_id not in [ext_part.existing_party for ext_part in existing_parties_new_atts if defined('ext_part.existing_party')]]
  - Attorneys: existing_parties_new_atts[i].attorney_adding_opts
    datatype: multiselect
    code: |
      tyler_filing_attorney_options
---
generic object: DAObject
code: |
  x.attorney_ids = x.attorney_adding_opts.true_values()
---
code: |
  attorney_ids = functools.reduce(lambda new_list, exst: exst.attorney_ids + new_list, users, [])
  for exst_user in existing_parties_new_atts:
    attorney_ids.extend(exst_user.attorney_ids) 
  party_to_attorneys = {y.instanceName: y.attorney_ids for y in users}
  for y in existing_parties_new_atts:
    party_to_attorneys[y.existing_party] = y.attorney_ids
---
id: location
question: | 
  What court will you file this case in?
fields:
  - Court Location: trial_court
    datatype: dropdown
    code: |
      trial_court_options
---
id: case category
question: |
  Case Category
fields:
  - Case Category: case_category
    datatype: dropdown
    code: |
      sorted(case_category_options,key=lambda cat: cat[1])
---
id: case type
question: |
  Case Type
fields:
  - Case Type: case_type
    datatype: dropdown
    code: |
      sorted(case_type_options,key=lambda cat: cat[1])
---
id: case subtype
question: |
  Case Subtype
fields:
  - Case Subtype: case_subtype
    datatype: dropdown
    code: |
      sorted(case_subtype_options,key=lambda cat: cat[1])
---
id: filing attorney
question: |
  Filing Attorney
subquestion: |
  % if filing_attorney_required_datafield.get('isrequired'):
  Only attorneys may file in this court
  % else:
  Leave the attorney field blank if you are filing this on your own
  behalf.
  % endif
fields:
  - Filing Attorney: tyler_filing_attorney
    datatype: dropdown
    code: |
      tyler_filing_attorney_options
    required: |
      filing_attorney_required_datafield.get('isrequired')
---
generic object: ALDocument
code: |
  # If policy prohibits sending the filing description, don't ask the question
  # TODO: how should the proxy handle this? '' is not the same as undefined
  if filing_description_datafield.get('isvisible') == False: # Treat None as visible
    x.filing_description = ''
---
id: is the user the plaintiff or defendant?
question: |
  Did you start this case, or are you responding to a case
  that someone else started?
subquestion: |
  ${ collapse_template(plaintiff_defendant_help_template) }
fields: 
  - Your role in this case: user_ask_role
    datatype: radio
    choices:
      - I started or I am starting a new case: plaintiff
      - I am responding to a case someone else started: defendant
---
template: plaintiff_defendant_help_template
subject: |
  How do I know?
content: |
  If you are the first person to file a form in the case, you 
  started the case. You are usually the "Plaintiff" or the "Petitioner."

  If you are responding to a case or court papers someone else filed, you
  are usually the "Defendant" or the "Respondent."
---
# code: |
#   # TODO: is this something we can assume? someone might be filing
#   # the first document in a case where they are a defendant, such
#   # as a mental health petition for discharge.
#   if filing_interview_initial_or_existing == 'initial_document':
#     user_ask_role = 'plaintiff'
---
id: your name
sets:
    - users[0].name.first
question:  |
  What is your name?
fields:
  - code: |
      users[0].name_fields(person_or_business='unknown' if not users[0].is_form_filler else 'ALIndividual', show_suffix=False)
---
question: |
  Are you this party?
subquestion: |
  Your information in the E-file system will be used
fields:
  - You are this party: users[0].is_form_filler
    datatype: yesnoradio
---
code: |
  if i > 0:
    users[i].is_form_filler = False
---
code: |
  # Can only get the attorney list for firm users, which can't be form fillers
  if proxy_conn.get_attorney_list().is_ok():
    users[0].is_form_filler = False
---
code: |
  if users[0].is_form_filler:
    tyler_info = proxy_conn.get_user()
    users[0].name.first = tyler_info.data.get('firstName')
    users[0].name.middle = tyler_info.data.get('middleName', '')
    users[0].name.last = tyler_info.data.get('lastName', '')
    users[0].email = tyler_info.data.get('email')
---
sets:
  - users[i].name.first
  - users[i].name.last
id: other users names
question: |
  What is the name of the ${ ordinal(i) } person who is part of the case with you?
fields:
  - code: |
      users[i].name_fields(show_suffix=False)
---
sets:
  - other_parties[i].name.first
id: names of opposing parties
question: |
  Name of ${ ordinal(i) } person on the opposing side of this case
fields:
  - code: |
      other_parties[i].name_fields(person_or_business='unsure', show_suffix=False)
---
id: name of ALIndividual
sets:
  - x.name.first
  - x.name.last
generic object: ALIndividual
question: |
  What is ${x.object_possessive('name')}?
fields:
  - code: |
      x.name_fields(show_suffix=False)
---
comment: |
  I removed language specific to defendant/plaintiff because
  there are several case types where that concept doesn't make sense.
  E.g., adoption has adoptive parent/child. But we can't special case
  each situation.
  
  Tyler doesn't care about users/other_parties--we ony use users to determine
  fee responsibility.
id: is there an opposing party?
question: |
  % if is_initial_filing:
  Is there an opposing party in this case?
  % else:
  Do you want to add more opposing parties to this case?
  % endif
subquestion: |
  An **opposing party** is someone who is on the other side of a legal case.
  
  % if is_initial_filing:
  % if user_started_case:
  Answer yes if there is a person or organization you are suing or taking to court.
  % else:
  Answer yes if someone else has sued you or is bringing you to court.
  % endif
  % else:
  The existing opposing parties include
  % endif
yesno: other_parties.there_are_any
---
id: any other opposing parties
question: |
  Is there any other opposing party?
yesno: other_parties.there_is_another  
---
id: party type of x
generic object: ALIndividual
question: |
  Party type of ${ x }?
fields:
  - Party Type: x.party_type_code
    input type: radio
    code: |
      party_type_options if is_nonindexed_filing else party_type_new_options
---
code: |
  if is_initial_filing or users[0].is_form_filler:
    if showifdef('user_ask_role') == 'plaintiff':
      plantiff = matching_tuple_option('plaintiff', party_type_options)
      petitioner = matching_tuple_option('petitioner', party_type_options)
      if plantiff:
        users[0].party_type_code = plantiff
      elif petitioner: 
        users[0].party_type_code = petitioner 
    else:
      defendant = matching_tuple_option('defendant', party_type_options)
      respond = matching_tuple_option('respondent', party_type_options)
      if defendant:
        users[0].party_type_code = defendant
      elif respond:
        users[0].party_type_code = respond    
---
id: party type of users
question: |
  Party type of ${ users[i] }?
fields:
  - Party Type: users[i].party_type_code
    input type: radio
    code: |
      party_type_options if is_nonindexed_filing else party_type_new_options
    default: ${ matching_tuple_option('plaintiff', party_type_options) if showifdef('user_ask_role') == 'plaintiff' else matching_tuple_option('defendant', party_type_options) }
---
id: party type of other parties
question: |
  Party type of ${ other_parties[i] }?
fields:
  - Party Type: other_parties[i].party_type_code
    input type: radio
    code: |
      party_type_options if is_nonindexed_filing else party_type_new_options
    default: ${ matching_tuple_option('defendant', party_type_options) if showifdef('user_ask_role') == 'plaintiff' else matching_tuple_option('plaintiff', party_type_options) }
---
# TODO(brycew): Need to force required filing types too
code: |
  def any_required(fc_opts, fc_map):
    new_list = list(filter(lambda ff: fc_map.get(ff, {}).get('required'), fc_opts))
    if new_list:
      return True
    else:
      return False
  def only_required_if_any(fc_opts, fc_map):
    new_list = list(filter(lambda ff: fc_map.get(ff, {}).get('required'), fc_opts))
    if new_list:
      return new_list
    else:
      return fc_opts
---
id: disclaimers
question: |
  Disclaimers
subquestion: |
  % if not disclaimers:
  No Disclaimers!
  % endif
fields:
  - no label: acknowledge_disclaimers
    datatype: checkboxes
    choices:
      - I certify that I have read and followed the instructions below: user_agrees_to_disclaimers
    minlength: 1
    show if:
      code: |
        len(disclaimers)
    validation messages:
      minlength: |
        You must acknowledge the disclaimers in order to continue
        with your filing.
under: |
  % if disclaimers:
  %for dis in disclaimers: 
  
  * ${ dis.get('requirementText') }
  % endfor
  % endif
continue button field: show_disclaimers
---
generic object: ALDocument
id: reference number
question: |
  Reference number
subquestion: |
  Optional -- add a unique reference number to track this case in your own
  filing system.
fields:
  - Reference Number (optional): x.reference_number
    datatype: text
    required: False
---
id: return date
question: |
  What would you like your Return Date to be?
fields:
  - Return Date: user_return_date
    datatype: date
    min: ${ today() }
    default: ${ today() }
---
id: optional service type
generic object: ALDocument
question: |
  Optional Services Type ${ i }
fields:
  - Optional Services: x.optional_services[i].code
    datatype: dropdown
    code: |
      x.optional_service_options
---
id: optional service multiplier
generic object: ALDocument
question: |
  How many "${ x.optional_service_map.get(x.optional_services[i].code).get('name') }"
  do you want?
subquestion: |
  Choose the number of ${ x.optional_service_map.get(x.optional_services[i].code).get('name') } that you want below.
  
  Usually this means the number of copies. This may affect
  the total fee for this service.  
fields:
  - Multiplier: x.optional_services[i].multiplier
    datatype: integer
    min: 1
    validate: |
      validate_tyler_regex(multiplier_datafield)
---
code: |
  multiplier_datafield = proxy_conn.get_datafield(court_id, 'OptionalServicesMultipleCopies').data or {}
---
id: cross reference type
question: |
  Cross references
# This works in Illinois at least--error message should be shown
# before user types, since it explains a confusing concept
subquestion: |
  % if len(cross_ref_type_map)==1 and next(iter(cross_ref_type_map.values()),{}).get('isrequired'):
  ${ next(iter(cross_ref_type_map.values()),{}).get('customvalidationfailuremessage') }
  % endif
fields:
  - Type of Reference: cross_references.new_item_name
    datatype: dropdown
    code: |
      cross_ref_types
    default: |
      ${ next(iter(cross_ref_type_map)) if len(cross_ref_type_map)==1 and next(iter(cross_ref_type_map.values()),{}).get('isrequired') else None }
  - Reference text: cross_references.new_item_value
validation code: |
  regex_str = cross_ref_type_map[cross_references.new_item_name]['validationregex']
  if not re.search(regex_str, cross_references.new_item_value):
    validation_error(cross_ref_type_map[cross_references.new_item_name]['customvalidationfailuremessage'], field="cross_references.new_item_value")
---
id: another cross reference
question: |
  Do you have any other types of cross references?
yesno: cross_references.there_is_another
---
id: optional service fee amount
generic object: ALDocument
question: |
  Optional Service ${ i } fee amount?
subquestion: |
  ${ x.optional_service_map.get(x.optional_services[i].code).get('feeprompttext') }
fields: 
  - Fee Amount: x.optional_services[i].fee_amount
    datatype: currency
---
id: you are responsible for payment
question: |
  Payment of fees (if any)
subquestion: |
  Because you are the only filer in this case, we have selected you as the
  user responsible for the fees.
  
  You will have a chance to review fees at the end of this form.
continue button field: explain_user_paying  
---
code: |
  service_contacts[i].contact_id
  service_contacts[i].service_type
  while not service_contacts[i].contact_id:
    del service_contacts[i].contact_id
    service_contacts[i].contact_id
  service_contacts[i].complete = True
---
code: |
  contacts_to_attach[i].contact_id
  while not contacts_to_attach[i].contact_id:
    del contacts_to_attach[i].contact_id
    contacts_to_attach[i].contact_id
  resp = proxy_conn.attach_service_contact(contacts_to_attach[i].contact_id, case_id=found_case.tracking_id)
  log(f'attempted attaching {contacts_to_attach[i].contact_id}: {resp}')
  del resp
  contacts_to_attach[i].complete = True
---
id: attach service contact to case
question: |
  Attach a Service Contact
subquestion: |
  % if service_contact_options:
  This will let you or other parties on the case serve filings to this contact.
  We'll ask if you want to serve them in this filing later.
  % else:
  You need to [add a service contact using the admin interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}) to continue.
  % endif
fields:
  - Contact Id: contacts_to_attach[i].contact_id
    datatype: dropdown
    code: |
      service_contact_options
---
# TODO: hack, but should work? Not sure if works for pro se filers
reconsider: service_contact_options
id: service contact
question: |
  Attach a Service Contact
subquestion: |
  % if service_contact_options:
  Select an existing contact below, or add a contact using the 
  [Admin Interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}
  
  If you add a new contact, refresh this screen to view the new contact.
  % else:
  You need to [add a service contact using the admin interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}) to continue.
  % endif
fields: 
  - Contact Id: service_contacts[i].contact_id
    datatype: dropdown
    code: |
      attached_service_contacts
  - Service Type: service_contacts[i].service_type
    datatype: dropdown
    code: |
      service_contact_options and service_type_options
  - Do you want to associate this service contact with a party?: service_contacts[i].attach_service_contact_to_party
    datatype: yesnoradio
    default: False
    show if:
      code: |
        service_contact_options and sum([u.is_new for u in users]) + sum([u.is_new for u in other_parties]) > 0
  - Which party is this contact for?: service_contacts[i].party_association
    datatype: radio
    required: False
    show if: service_contacts[i].attach_service_contact_to_party
    code: |
      [{user.instanceName: str(user)} for user in users if user.is_new] + [{pty.instanceName: str(pty)} for pty in other_parties if pty.is_new] + [{part.tyler_id: str(part.name)} for part in (found_case.participants if defined('found_case.participants') else [])]
continue button label: ${'Continue' if service_contact_options else 'Try again'}
---
id: existing service contacts
question: |
  Do you want to serve a service contact in this filing?
yesno: service_contacts.there_are_any
---
id: attach service contacts
question: |
  Do you want to attach a service contact to this case for others or yourself to serve?
yesno: contacts_to_attach.there_are_any
---
id: Any more existing service contacts
question: |
  Do you want to serve any more service contacts?
yesno: service_contacts.there_is_another
---
id: any more attaching service contacts
question: |
  Do you want to attach any more service contacts to this case?
yesno: contacts_to_attach.there_is_another
---
id: your email
question: |
  Confirm your email address
subquestion: |
  You need to provide an email address to file this form.
  We will use this address to update you on your filing status.
fields:
  - Email: users[0].email
    datatype: email
    default: ${ showifdef('my_username') }
---
id: your form is submitted
event: summary_page
question: |
  % if efile_resp.is_ok():
  Your form is submitted!
  % else:
  Something went wrong submitting your form.
  % endif
subquestion: |
  You can still download a copy for your records.
  
  ${ al_court_bundle.download_list_html()}
#subquestion: |
#  % if ready_to_efile and not (defined('efile') and efile):
#  Click the "E-File" button below te e-file your form at ${ trial_court }.
#
#  ${ action_button_html(url_ask([{'recompute': ['efile']}]), label='E-file', icon='file-export')}
#  % endif
---
id: something went wrong
event: go_back_screen
question: |
  Something went wrong
subquestion: |
  Your selections aren't working. :/  Please try again.
---
code: |
  trial_court_resp = proxy_conn.get_courts(fileable_only=True, with_names=True)
  trial_court_options = [(court['code'], court['name']) for court in trial_court_resp.data]
---
code: |
  timing = 'Initial' if is_initial_filing else 'Subsequent'
  case_category_options, case_category_map = choices_and_map(proxy_conn.get_case_categories(court_id, fileable_only=True, timing=timing).data) 
  if not case_category_options:
    go_back_screen
---
code: |
  timing = 'Initial' if is_initial_filing else 'Subsequent'
  case_type_options, case_type_map = choices_and_map(proxy_conn.get_case_types(court_id, case_category, timing=timing).data)
  if not case_type_options:
    go_back_screen
---
code: |
  case_subtype_options, case_subtype_map = choices_and_map(proxy_conn.get_case_subtypes(court_id, case_type).data)
---
code: |
  tyler_filing_attorney_options, tyler_filing_attorney_map = choices_and_map(proxy_conn.get_attorney_list().data, 
      display='{firstName} {middleName} {lastName}',
      backing='attorneyID')
---
code: |
  court_policy = proxy_conn.get_policy(court_id).data or {}
---
code: |  
  filing_attorney_required_datafield = proxy_conn.get_datafield(court_id, 'FilingFilingAttorneyView').data or {}
---
code: |
  disclaimers = proxy_conn.get_disclaimers(court_id).data
---
code: |
  party_type_options, party_type_map = \
    choices_and_map(proxy_conn.get_party_types(court_id, case_type).data)
  party_type_new_options = [p_type for p_type in party_type_options] 
  # TODO(brycew): need to prevent multiple parties using the isAvailableForNewParties = False entries 
  # if party_type_map[p_type[0]].get('isAvailableForNewParties')]
---
generic object: ALDocument
code: |
  x.motion_type_options, x.motion_type_map = choices_and_map(proxy_conn.get_motion_types(court_id, x.filing_type).data)
---
code: |
  service_type_options, service_type_map = choices_and_map(proxy_conn.get_service_types(jurisdiction_id, court_id).data)
  cross_ref_types, cross_ref_type_map = choices_and_map(proxy_conn.get_cross_references(court_id, case_type).data, backing='code')
---
code: |
  service_contact_options = parse_service_contacts(proxy_conn.get_service_contact_list().data)
---
code: |
  attached_service_contacts = []
  if not needs_all_info:
    resp_data = proxy_conn.get_service_information(court_id, found_case.tracking_id).data
    attached_service_contacts = parse_service_contacts(resp_data)
---
comment: |
  service_information
---