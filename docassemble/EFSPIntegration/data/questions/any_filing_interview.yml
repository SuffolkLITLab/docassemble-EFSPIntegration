---
modules:
  - .efm_client
---
include:
  - login_qs.yml
  - efiling_integration.yml
  - docassemble.AssemblyLine:al_package.yml
  - case_search.yml
---
code: |
  user_wants_efile = True # This interview is always for e-filing
---
code: |
  jurisdiction_id = 'illinois'
---
code: |
  user_registration_choices = [
    ('INDIVIDUAL', 'Pro Se user'),
    ('FIRM_ADMINISTRATOR', 'Administrator of a new firm'),
    ('FIRM_ADMIN_NEW_MEMBER', 'New member of current firm')
  ]
---
mandatory: True
code: |
  welcome
  tyler_login 
  trial_court
  can_check_efile
  if is_initial_filing:
    tyler_case_category = case_category_map.get(case_category,{}).get('name')
    tyler_case_type = case_type_map.get(case_type,{}).get('name')
    if case_subtype_options:
      tyler_case_subtype = case_subtype_map.get(case_subtype).get('name')
    tyler_filing_attorney
    user_ask_role
    user_started_case
  else:
    interview_order_find_case
    load_existing_case_defaults
    previous_case_id = case_tracking_id
    user_started_case
    is_adding_new_parties

  users.gather()
  other_parties.gather()
  all_case_parties
  if is_initial_filing:
    lead_contact = users[0]
    reconsider('missing_required_party_types')
    if missing_required_party_types:
      party_review_screen
      
  else:
    lead_contact.name.first
  
  lead_doc.completed
  append_lead_doc    
  al_court_bundle.auto_gather=True  
  al_court_bundle.gather()
  
  service_contacts.gather()
  cross_references.gather()
  # TODO: as_pdf() is slow and may not be right if no document uploaded
  al_court_bundle.as_pdf()
  
  if is_initial_filing:
    users[0].email
  
  if full_court_info.data['allowreturndate']:
    return_date
    show_allowed_return_date

  if is_initial_filing and len(users) == 1:
    explain_user_paying

  tyler_payment_id

  if can_check_efile:
    if is_initial_filing:
      users[0].email
    #TODO(qs): if not a waiver account...
    ready_to_efile
    review_fees

  show_disclaimers
  efile
  summary_page
  #submitted_page
---
code: |
  proxy_conn = ProxyConnection(credential_code_block='tyler_login')
---
features:
  question back button: True
  navigation back button: False
---
objects:
  - lead_contact: ALIndividual
---
objects:
  - users: ALPeopleList.using(there_are_any=is_initial_filing or is_adding_new_parties, complete_attribute='complete')
  - other_parties: ALPeopleList.using(complete_attribute='complete') # NOTE that there can be filing types with no opposing party, such as adoption
---
objects:
  - lead_doc: ALExhibitDocument.using(title="Lead Filing Doc", filename="lead_filing_doc", include_table_of_contents=False, include_exhibit_cover_pages=False)
  
---
code: |
  al_court_bundle.clear()
  al_court_bundle.append(lead_doc)
  
  append_lead_doc = True
---
generic object: ALDocument
code: |
  # Every filing type needs an associated document
  x.exhibits.has_exhibits = True
---
generic object: ALDocument
code: |
  # You can only have exactly one exhibit per ALExhibitDocument
  # for this filing interview
  x.exhibits.has_exhibits = True
  x.exhibits.ask_number = True
  x.exhibits.target_number = 1
---
generic object: ALDocument
id: any exhibits
question: |
  Please upload your documents
subquestion: |
  You will have a chance to upload multiple documents. 
  You can also add additional pages to this document.
fields:
  - Filing Type: x.filing_type
    datatype: dropdown
    code: |
      sorted(filing_type_options, key=lambda option: option[1])
  - label: |
      Description
      % if not filing_description_datafield.get('isrequired'):
      (optional)
      % endif
    field: x.filing_description
    datatype: text
    required: |
      filing_description_datafield.get('isrequired', False)   
  - Reference Number (optional): x.reference_number
    datatype: text
    required: False
  - Document: x.exhibits[0].pages
    datatype: files
    maximum image size: 1024
    image upload type: jpeg        
    accept: |
      "image/png, image/jpeg, .doc,.docx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/pdf,.pdf"
  - Add a courtesy email: x.has_courtesy_copies
    datatype: yesno
  - Courtesy emails (one per line): x.courtesy_copies_raw
    datatype: area  
    show if: x.has_courtesy_copies
validation code: |
  if sum(exhibit.size_in_bytes() for exhibit in x.exhibits[0].pages) > (15 * 1024 * 1024):
    validation_error("Upload a file smaller than 15 MB.")
  try:
    pdf_concatenate(x.exhibits[0].pages)
  except:
    validation_error("Unable to convert this file. Please upload a new one.", field="x.exhibits[0].pages")
  x.exhibits[0].pages.reset_gathered()  # docassemble sets this attribute but we want to force gathering additional pages

  if x.has_courtesy_copies:
    x.courtesy_copies = x.courtesy_copies_raw.splitlines()
    for copy in x.courtesy_copies:
      if not '@' in copy:
        validation_error("Enter a valid email address.", field="x.courtesy_copies_raw")
        break     
---
generic object: ALExhibitDocument
code: |
  x.exhibits[i].title = x.filing_description if x.filing_description else filing_type_map.get(x.filing_type,{}).get('name')
---  
generic object: ALExhibitDocument
code: |
  x.filename = space_to_underscore(x.exhibits[0].title)
---
id: another exhibit
question: |
  You have ${ al_court_bundle.number_gathered() } document(s) so far. Do you have another document
  you want to upload?
#subquestion: |
#  ${ collapse_template(x.in_progress_exhibits) }
field: al_court_bundle.there_is_another
buttons:
  - Finished adding documents: False
  - Add another document: True
---
generic object: ALExhibitList
template: x.in_progress_exhibits
subject: |
  Preview your documents so far
content: |
  ${ x.rearrange_exhibits_table }
---
generic object: ALExhibitList
table: x.rearrange_exhibits_table
rows: x
allow reordering: True
delete buttons: True
columns:
  - ${ al_exhibit_title_label }: |
      row_item.title
  - ${ al_exhibit_preview_label }: |
      row_item.pages.show(width="50%")
  - ${ al_exhibit_total_pages_label }: |
      row_item.pages.num_pages()
edit:
  - rearrange_pages  
---
objects:
  - service_contacts: DAList.using(object_type=DAObject, complete_attribute='complete')
---
objects:
  - cross_references: DADict.using(there_are_any=len(cross_ref_types))
---
generic object: ALExhibitDocument
code: |
  x.enabled = True
---
generic object: ALExhibitDocument
objects:
  - x.optional_services: DAList.using(object_type=DAObject)
---
objects:
  - al_court_bundle: ALDocumentBundle.using(filename="full_bundle.pdf", title="All forms to submit to the court", object_type=ALExhibitDocument, complete_attribute = 'completed', gathered=False, auto_gather=True, there_are_any=True)
---
code: |
  if is_initial_filing:
    al_form_type = 'starts_case'
  else:
    al_form_type = 'existing_case'
---
id: review_fees
question: |
  Review filing fees
subquestion: |
  Your payment account will be charged the following fees:
  
  % if has_fees:
  ${ fees_table }
  
  **Total: ${ currency(fee_total(fees_resp)) }**
  % else:
  There are no fees associated with this filing.
  % endif  
fields:
  - no label: review_fees
    datatype: checkboxes
    choices:
      - ${ 'I agree to pay the listed fees of' + str(currency(fee_total(fees_resp))) if has_fees else 'No fees' }: agrees_to_pay_fees
    minlength: 1
    validation messages:
      minlength: |
        You must agree to pay the fees listed above.
    #show if:
    #  code: |
    #    has_fees
#continue button field: review_fees        
---
depends on:
  - fees_resp
code: |
  has_fees = fee_total(fees_resp) and float(fee_total(fees_resp)) > 0
---
code: |
  fees_resp = proxy_conn.calculate_filing_fees(court_id, al_court_bundle)
---
depends on:
  - fees_resp
table: fees_table
rows: |
  [fee for fee in fees_resp.data.get('allowanceCharge',[]) if fee.get('chargeIndicator',{}).get('value')]
columns:
  - Reason: |
      row_item.get('allowanceChargeReason',{}).get('value')
  - Amount: |
      currency(row_item.get('amount',{}).get('value',0))
---
code: |
  def fee_total(my_resp):
    if my_resp.data:
      return my_resp.data.get('feesCalculationAmount',{}).get('value')      
---
generic object: ALIndividual
code: |
  str(x.name)
  x.party_type = party_type_map.get(x.party_type_code).get('name')
  x.complete = True
---
code: |
  no_missing_required_party_types_temp = True
  for p_type in party_type_map.values():
    no_missing_required_party_types_temp &= (
      any(filter(lambda p: p.party_type_code == p_type.get('code'), users)) or
      any(filter(lambda p: p.party_type_code == p_type.get('code'), other_parties))
      )
  missing_required_party_types = not no_missing_required_party_types_temp
  del no_missing_required_party_types_temp
---
generic object: ALPeopleList
table: x.review_type_table
rows: x
columns:
  - Name: |
      row_item.name.full()
  - Type: |
      party_type_map.get(row_item.party_type_code,{}).get('name')
edit:
  - party_type_code  
---
sets:
  - lead_contact.name.first
question: |
  Who should be contacted about this filing?
fields:
  - email: lead_contact.email
    datatype: email
  - code: |
      lead_contact.name_fields()
---
id: review parties
continue button field: party_review_screen
question: |
  Review parties
subquestion: |
  % if missing_required_party_types:
  ### Warning: you are missing a required party type!
  
  This case requires that you have at least one:
  
  % for p_type in party_type_map.values():
  * ${ p_type.get('name') }
  % endfor
  
  % endif
  #### Parties on your side of the case
  ${ users.review_type_table }
  ${ users.add_action() }
  
  #### Other parties
  ${ other_parties.review_type_table }
  ${ other_parties.add_action() }
---
code: |
  return_date = proxy_conn.get_return_date(court_id, user_return_date, al_court_bundle)
---
generic object: ALDocument
code: |
  x.filing_type
  x.filing_description
  x.reference_number
  x.tyler_filing_type 
  x.document_type
  x.motion_type
  x.filing_component
  if x.exhibits.has_exhibits:
    x.as_pdf()
  x.filing_parties
  x.optional_services.gather(complete_attribute='complete')  
  x.completed =True
---
generic object: ALDocument
code: |
  x.tyler_filing_type = filing_type_map.get(x.filing_type,{}).get('name')
---
generic object: ALDocument
code: |
  x.document_type = x.document_type_map.get(x.document_type_code,{}).get('name')
---
generic object: ALDocument
code: |
  x.filing_component = x.filing_component_map.get(x.filing_component_code,{}).get('name')
---
id: Additional parties
question: |
  Are you adding any additional parties to this filing?
yesno: is_adding_new_parties
---
id: make a filing
question: |
  Make a Filing
subquestion: |
  Welcome! You can make any type of filing in an Illinois court, to a pre-existing or new case, in this interview.
continue button field: welcome
---
id: return date
question: |
  The next available return date is below
subquestion: |
  % if return_date.is_ok() and return_date.data.get('systemEventDateTime'):
  ${ tyler_timestamp_to_datetime( return_date.data.get('systemEventDateTime').get('value') ) }
  % else:
  Something went wrong retrieving a return date
  
  ${ return_date }
  % endif
continue button field: show_allowed_return_date
---
id: initial filing
question: |
  Are you filing into a new case or an existing one?
field: filing_interview_initial_or_existing
choices:
  - I am starting a new case: initial_document
  - I am adding a document to an existing case: existing_case
---
code: |
  is_initial_filing = filing_interview_initial_or_existing == 'initial_document'
---
code: |
  # NOTE we could refactor case_search.yml to use a datatype: object selector
  # but I think this essentially works the same in the background
  selected_existing_case = found_case
---
code: |
  if selected_existing_case:
    if selected_existing_case.category:
      case_category = selected_existing_case.category
    if selected_existing_case.case_type:
      case_type = selected_existing_case.case_type
    full_case_query = proxy_conn.get_case(court_id, selected_existing_case.tracking_id)
    # TODO(brycew): get party info from existing case to select filing parties 
    exising_case_parties = None
  load_existing_case_defaults = True
---
id: location
question: | 
  What court will you file this case in?
fields:
  - Court Location: trial_court
    datatype: dropdown
    code: |
      trial_court_options
---
id: case category
question: |
  Case Category
fields:
  - Case Category: case_category
    datatype: dropdown
    code: |
      sorted(case_category_options,key=lambda cat: cat[1])
---
id: case type
question: |
  Case Type
fields:
  - Case Type: case_type
    datatype: dropdown
    code: |
      sorted(case_type_options,key=lambda cat: cat[1])
---
id: case subtype
question: |
  Case Subtype
fields:
  - Case Subtype: case_subtype
    datatype: dropdown
    code: |
      sorted(case_subtype_options,key=lambda cat: cat[1])
---
id: filing attorney
question: |
  Filing Attorney
subquestion: |
  % if filing_attorney_required_datafield.get('isrequired'):
  Only attorneys may file in this court
  % else:
  Leave the attorney field blank if you are filing this on your own
  behalf.
  % endif
fields:
  - Filing Attorney: tyler_filing_attorney
    datatype: dropdown
    code: |
      tyler_filing_attorney_options
    required: |
      filing_attorney_required_datafield.get('isrequired')
---
reconsider:
  - tyler_payment_account_options
id: payment account
question: |
  Payment Account
subquestion: |
  Select an existing account below, or add a payment account
  using the 
  [Admin Interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}
  
  Refresh this page when you have finished adding the account.
fields:
  - Payment Account: tyler_payment_id
    datatype: dropdown
    code: |
      tyler_payment_account_options
---
generic object: ALDocument
code: |
  # If policy prohibits sending the filing description, don't ask the question
  # TODO: how should the proxy handle this? '' is not the same as undefined
  if filing_description_datafield.get('isvisible') == False: # Treat None as visible
    x.filing_description = ''
---
id: is the user the plaintiff or defendant?
question: |
  Did you start this case, or are you responding to a case
  that someone else started?
subquestion: |
  ${ collapse_template(plaintiff_defendant_help_template) }
fields: 
  - Your role in this case: user_ask_role
    datatype: radio
    choices:
      - I started or I am starting a new case: plaintiff
      - I am responding to a case someone else started: defendant
---
template: plaintiff_defendant_help_template
subject: |
  How do I know?
content: |
  If you are the first person to file a form in the case, you 
  started the case. You are usually the "Plaintiff" or the "Petitioner."

  If you are responding to a case or court papers someone else filed, you
  are usually the "Defendant" or the "Respondent."
---
# code: |
#   # TODO: is this something we can assume? someone might be filing
#   # the first document in a case where they are a defendant, such
#   # as a mental health petition for discharge.
#   if filing_interview_initial_or_existing == 'initial_document':
#     user_ask_role = 'plaintiff'
---
id: your name
sets:
    - users[0].name.first
    - users[0].name.last
question:  |
  What is your name?
fields:
  - code: |
      users[0].name_fields(show_suffix=False)
---
sets:
  - users[i].name.first
  - users[i].name.last
id: other users names
question: |
  What is the name of the ${ ordinal(i) } person who is part of the case with you?
fields:
  - code: |
      users[i].name_fields(show_suffix=False)
---
sets:
  - other_parties[i].name.first
id: names of opposing parties
question: |
  Name of ${ ordinal(i) } person on the opposing side of this case
fields:
  - code: |
      other_parties[i].name_fields(person_or_business='unsure', show_suffix=False)
---
id: name of ALIndividual
sets:
  - x.name.first
  - x.name.last
generic object: ALIndividual
question: |
  What is ${x.object_possessive('name')}?
fields:
  - code: |
      x.name_fields(show_suffix=False)
---
comment: |
  I removed language specific to defendant/plaintiff because
  there are several case types where that concept doesn't make sense.
  E.g., adoption has adoptive parent/child. But we can't special case
  each situation.
  
  Tyler doesn't care about users/other_parties--we ony use users to determine
  fee responsibility.
id: is there an opposing party?
question: |
  Is there an opposing party in this case?
subquestion: |
  An **opposing party** is someone who is on the other side of a legal case.
  
  % if user_started_case:
  Answer yes if there is a person or organization you are suing or taking to court.
  % else:
  Answer yes if someone else has sued you or is bringing you to court.
  % endif
yesno: other_parties.there_are_any
---
id: any other opposing parties
question: |
  Is there any other opposing party?
yesno: other_parties.there_is_another  
---
code: |
  other_parties.there_are_any = is_adding_new_parties if defined('is_adding_new_parties') else other_parties.there_are_any
---
id: party type of x
generic object: ALIndividual
question: |
  Party type of ${ x }?
fields:
  - Party Type: x.party_type_code
    input type: radio
    code: |
      party_type_options
---
code: |
  if showifdef('user_ask_role') == 'plaintiff' and matching_tuple_option('plaintiff', party_type_options):
    users[0].party_type_code = matching_tuple_option('plaintiff', party_type_options)
  elif showifdef('user_ask_role') == 'plaintiff' and matching_tuple_option('petitioner', party_type_options):
    users[0].party_type_code = matching_tuple_option('petitioner', party_type_options)    
  elif matching_tuple_option('defendant', party_type_options):
    users[0].party_type_code =  matching_tuple_option('defendant', party_type_options)
  elif matching_tuple_option('respondent', party_type_options):
    users[0].party_type_code =  matching_tuple_option('respondent', party_type_options)    
---
id: party type of users
question: |
  Party type of ${ users[i] }?
fields:
  - Party Type: users[i].party_type_code
    input type: radio
    code: |
      party_type_options
    default: ${ matching_tuple_option('plaintiff', party_type_options) if showifdef('user_ask_role') == 'plaintiff' else matching_tuple_option('defendant', party_type_options) }
---
id: party type of other parties
question: |
  Party type of ${ other_parties[i] }?
fields:
  - Party Type: other_parties[i].party_type_code
    input type: radio
    code: |
      party_type_options
    default: ${ matching_tuple_option('defendant', party_type_options) if showifdef('user_ask_role') == 'plaintiff' else matching_tuple_option('plaintiff', party_type_options) }

---
code: |
  def matching_tuple_option(option:str, options:List[Tuple]):
    return next(filter(lambda type: option in type[1].lower(), options),[None])[0]
---
id: document type
generic object: ALDocument
question: |
  Document type - ${ x.exhibits[0].title }
subquestion: |
  If a judge has ordered that this case is sealed, select
  "Confidential". You should also attach a copy of the judge's order.
fields:
  - Document type: x.document_type_code
    input type: radio
    code: |
      x.document_type_options
    default: ${ matching_tuple_option('non-confidential', x.document_type_options) }
---
id: filing component
generic object: ALDocument
if: |
  not exactly_one_required_filing_component(x.filing_component_options, x.filing_component_map)
question: |
  Filing Component
fields:
  - Filing Component: x.filing_component_code
    datatype: dropdown
    code: |
      x.filing_component_options
---
generic object: ALDocument
if: |
  exactly_one_required_filing_component(x.filing_component_options, x.filing_component_map)
code: |
  x.filing_component_code = next(iter(x.filing_component_options))[0]
---
generic object: ALDocument
id: motion_type
question: |
  Motion Type
fields:
  - Motion Type: x.motion_type_code
    datatype: dropdown
    code: |
      x.motion_type_options
---
generic object: ALDocument
code: |
  if x.motion_type_options:
    x.motion_type = x.motion_type_map.get(x.motion_type_code)
  else:
    x.motion_type = None
---
code: |
  def exactly_one_required_filing_component(fc_opts, fc_map):
    if len(fc_opts) > 1:
      return False
    filing_component_code = next(iter(fc_opts))[0]
    return fc_map.get(filing_component_code,{}).get('required')
---
# TODO(brycew): Need to force required filing types too
code: |
  def any_required(fc_opts, fc_map):
    new_list = list(filter(lambda ff: fc_map.get(ff, {}).get('required'), fc_opts))
    if new_list:
      return True
    else:
      return False
  def only_required_if_any(fc_opts, fc_map):
    new_list = list(filter(lambda ff: fc_map.get(ff, {}).get('required'), fc_opts))
    if new_list:
      return new_list
    else:
      return fc_opts
---
id: disclaimers
question: |
  Disclaimers
subquestion: |
  % if not disclaimers:
  No Disclaimers!
  % endif
fields:
  - no label: acknowledge_disclaimers
    datatype: checkboxes
    choices:
      - I certify that I have read and followed the instructions below: user_agrees_to_disclaimers
    minlength: 1
    show if:
      code: |
        len(disclaimers)
    validation messages:
      minlength: |
        You must acknowledge the disclaimers in order to continue
        with your filing.
under: |
  % if disclaimers:
  %for dis in disclaimers: 
  
  * ${ dis.get('requirementText') }
  % endfor
  % endif
continue button field: show_disclaimers
---
generic object: ALDocument
id: reference number
question: |
  Reference number
subquestion: |
  Optional -- add a unique reference number to track this case in your own
  filing system.
fields:
  - Reference Number (optional): x.reference_number
    datatype: text
    required: False
---
id: return date
question: |
  Return Date?
fields:
  - Return Date: user_return_date
    datatype: date
    min: ${ today() }
---
id: any optional services
generic object: ALDocument
question: |
  Optional services - ${ x.exhibits[0].title }
subquestion: |
  Do you want to add any optional services for this document?
yesno: x.optional_services.there_are_any
---
generic object: ALDocument
code: |
  if not x.optional_service_options:
    x.optional_services.there_are_any = False
---
id: another optional service
generic object: ALDocument
question: |
  Are there any other optional services that you want for ${ x.title }?
yesno: x.optional_services.there_is_another
---
code: |
  al_court_bundle[i].title = al_court_bundle[i].exhibits[0].title
---
generic object: ALDocument
code: |
  my_code = x.optional_services[i].code
  if x.optional_service_map.get(my_code,{}).get('multiplier'):
    x.optional_services[i].multiplier
  if x.optional_service_map.get(my_code,{}).get('hasfeeprompt'):
    x.optional_services[i].fee_amount
  x.optional_services[i].complete = True
---
id: optional service type
generic object: ALDocument
question: |
  Optional Services Type ${ i }
fields:
  - Optional Services: x.optional_services[i].code
    datatype: dropdown
    code: |
      x.optional_service_options
---
id: optional service multiplier
generic object: ALDocument
question: |
  How many "${ x.optional_service_map.get(x.optional_services[i].code).get('name') }"
  do you want?
subquestion: |
  Choose the number of ${ x.optional_service_map.get(x.optional_services[i].code).get('name') } that you want below.
  
  Usually this means the number of copies. This may affect
  the total fee for this service.  
fields:
  - Multiplier: x.optional_services[i].multiplier
    datatype: integer
    min: 1
    validate: |
      validate_tyler_regex(multiplier_datafield)
---
code: |
  multiplier_datafield = proxy_conn.get_datafield(court_id, 'OptionalServicesMultipleCopies').data or {}
---
id: cross reference type
question: |
  Cross references
# This works in Illinois at least--error message should be shown
# before user types, since it explains a confusing concept
subquestion: |
  % if len(cross_ref_type_map)==1 and next(iter(cross_ref_type_map.values()),{}).get('isrequired'):
  ${ next(iter(cross_ref_type_map.values()),{}).get('customvalidationfailuremessage') }
  % endif
fields:
  - Type of Reference: cross_references.new_item_name
    datatype: dropdown
    code: |
      cross_ref_types
    default: |
      ${ next(iter(cross_ref_type_map)) if len(cross_ref_type_map)==1 and next(iter(cross_ref_type_map.values()),{}).get('isrequired') else None }
  - Reference text: cross_references.new_item_value
validation code: |
  regex_str = cross_ref_type_map[cross_references.new_item_name]['validationregex']
  if not re.search(regex_str, cross_references.new_item_value):
    validation_error(cross_ref_type_map[cross_references.new_item_name]['customvalidationfailuremessage'], field="cross_references.new_item_value")
---
id: another cross reference
question: |
  Do you have any other types of cross references?
yesno: cross_references.there_is_another
---
id: optional service fee amount
generic object: ALDocument
question: |
  Optional Service ${ i } fee amount?
subquestion: |
  ${ x.optional_service_map.get(x.optional_services[i].code).get('feeprompttext') }
fields: 
  - Fee Amount: x.optional_services[i].fee_amount
    datatype: currency
---
generic object: ALDocument
id: Parties resp for payment
question: |
  Parties responsible for payment
fields: 
  - Parties for payment: x.existing_parties_payment_dict
    datatype: checkboxes
    code: |
      all_case_parties
---
generic object: ALDocument
code: |
  if is_initial_filing and len(users) == 1:
    x.filing_parties = ['users[0]']
    # explain_user_paying
  else:
    x.filing_parties = list(x.existing_parties_payment_dict.true_values())
---
code: |
  filing_parties = next(lead_doc.filing_parties)
---
id: you are responsible for payment
question: |
  Payment of fees (if any)
subquestion: |
  Because you are the only filer in this case, we have selected you as the
  user responsible for the fees.
  
  You will have a chance to review fees at the end of this form.
continue button field: explain_user_paying  
---
code: |
  service_contacts[i].contact_id
  service_contacts[i].service_type
  service_contacts[i].party_association
  service_contacts[i].complete = True
---
# TODO: hack, but should work? Not sure if works for pro se filers
reconsider: service_contact_options
id: service contact
question: |
  Service Contact
subquestion: |
  Select an existing contact below, or add a contact
  using the 
  [Admin Interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}
  
  If you add a new contact, refresh this screen to view the new contact.
fields: 
  - Contact Id: service_contacts[i].contact_id
    datatype: dropdown
    code: |
      service_contact_options
  - Service Type: service_contacts[i].service_type
    datatype: dropdown
    code: | 
      service_type_options
  - Which party is this contact for?: service_contacts[i].party_association
    datatype: radio
    code: |
      all_case_parties
---
id: existing service contacts
question: |
  Do you want to add a service contact?
yesno: service_contacts.there_are_any
---
id: Any more existing service contacts
question: |
  Any more service contacts?
yesno: service_contacts.there_is_another
---
id: your email
question: |
  Confirm your email address
subquestion: |
  You need to provide an email address to file this form.
  We will use this address to update you on your filing status.
fields:
  - Email: users[0].email
    datatype: email
    default: ${ showifdef('my_username') }
---
id: your form is submitted
event: summary_page
question: |
  % if efile_resp.is_ok():
  Your form is submitted!
  % else:
  Something went wrong submitting your form.
  % endif
subquestion: |
  You can still download a copy for your records.
  
  ${ al_court_bundle.download_list_html()}
#subquestion: |
#  % if ready_to_efile and not (defined('efile') and efile):
#  Click the "E-File" button below te e-file your form at ${ trial_court }.
#
#  ${ action_button_html(url_ask([{'recompute': ['efile']}]), label='E-file', icon='file-export')}
#  % endif
---
id: submitted page
event: submitted_page
question: |
  Yay
---
id: something went wrong
event: go_back_screen
question: |
  Something went wrong
subquestion: |
  Your selections aren't working. :/  Please try again.
---
code: |
  trial_court_resp = proxy_conn.get_courts(fileable_only=True, with_names=True)
  log(trial_court_resp.data)
  trial_court_options = [(court['code'], court['name']) for court in trial_court_resp.data]
---
code: |
  full_court_info = proxy_conn.get_court(court_id)
---
code: |
  case_category_options, case_category_map = choices_and_map(proxy_conn.get_case_categories(court_id, filable_only=True).data)
  if not case_category_options:
    go_back_screen
---
code: |
  case_type_options, case_type_map = choices_and_map(proxy_conn.get_case_types(court_id, case_category, timing='Initial' if is_initial_filing else 'Subsequent').data)
  if not case_type_options:
    go_back_screen
---
code: |
  case_subtype_options, case_subtype_map = choices_and_map(proxy_conn.get_case_subtypes(court_id, case_type).data)
---
code: |
  tyler_filing_attorney_options, tyler_filing_attorney_map = choices_and_map(proxy_conn.get_attorney_list().data, 
      display='{firstName} {middleName} {lastName}',
      backing='attorneyID')
---
code: |
  allowable_card_types = full_court_info.data.get('allowablecardtypes', [])
  res = proxy_conn.get_payment_account_list().data
  if res:
    tyler_payment_account_options = filter_payment_accounts(res, allowable_card_types)
  else:
    tyler_payment_account_options = []

  res = proxy_conn.get_global_payment_account_list().data
  if res:
    tyler_payment_account_options.extend(filter_payment_accounts(res, allowable_card_types)) 
---
code: |
  court_policy = proxy_conn.get_policy(court_id).data or {}
---
code: |
  filing_description_datafield = proxy_conn.get_datafield(court_id, 'FilingFilingDescription').data or {}
---
code: |  
  filing_attorney_required_datafield = proxy_conn.get_datafield(court_id, 'FilingFilingAttorneyView').data or {}
---
code: |
  disclaimers = proxy_conn.get_disclaimers(court_id).data
---
code: |
  filing_type_options, filing_type_map = choices_and_map(proxy_conn.get_filing_types(court_id, case_category, case_type, is_initial_filing).data)
---
code: |
  party_type_options, party_type_map = \
    choices_and_map(proxy_conn.get_party_types(court_id, case_type).data)
---
generic object: ALDocument
code: |
  raw_opt_servs = proxy_conn.get_optional_services(court_id, x.filing_type).data
  x.optional_service_options, x.optional_service_map = choices_and_map(raw_opt_servs)
---
generic object: ALDocument
code: |
  raw_components = proxy_conn.get_filing_components(court_id, x.filing_type)
  log('raw_components: ' + str(raw_components))
  x.filing_component_options, x.filing_component_map = choices_and_map(raw_components.data)
  log('map: ' + str(x.filing_component_map))
---
generic object: ALDocument
code: |
  x.motion_type_options, x.motion_type_map = choices_and_map(proxy_conn.get_motion_types(court_id, x.filing_type).data)
---
generic object: ALDocument
code: |
  x.document_type_options, x.document_type_map = choices_and_map(proxy_conn.get_document_types(court_id, x.filing_type).data)
---
code: |
  service_type_options, service_type_map = choices_and_map(proxy_conn.get_service_types(court_id).data)
  cross_ref_types, cross_ref_type_map = choices_and_map(proxy_conn.get_cross_references(court_id, case_type).data, backing='name')
---
code: |
  service_contact_options = [(vv.get('serviceContactID'), f"{vv.get('firstName')} {vv.get('middleName')} {vv.get('lastName')}") for vv in proxy_conn.get_service_contact_list().data]
---
comment: |
  service_information
  submitted_page
---
code: |    
  if is_initial_filing or is_adding_new_parties:
    all_case_parties_tmp = [{user.instanceName: str(user)} for user in users]
  else:
    all_case_parties_tmp = []
        
  if not is_initial_filing:
    raw_party_list = next(filter(lambda augmentation: augmentation.get('declaredType') == "tyler.ecf.extensions.common.CaseAugmentationType", found_case.case_details.get('value',{}).get('rest',[{}])), {}).get('value',{}).get('caseParticipant',[])
    all_case_parties_tmp.extend([get_person_name_and_id(party) for party in raw_party_list if is_person(party)])

  all_case_parties = all_case_parties_tmp
  del all_case_parties_tmp
