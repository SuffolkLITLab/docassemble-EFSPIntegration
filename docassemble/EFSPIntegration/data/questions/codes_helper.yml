---
include:
  - efiling_integration.yml
---
comment: |
  generic object only works on a single type of object. However, in ALDocumentBundles, we
  treat ALDocuments and ALDocumentBundles the same: we just call as_pdf().
  From the Tyler perspective, authors should be able to declare at what level the ALDocument
  or ALDocumentBundles are going to be combined and sent to Tyler, and at that level, we need
  to define all of the below attributes (tyler_filing_type, etc.)

  For simplicity, the generic objects below will mostly be DAObjects, to catch both ALDocumentBundles
  and ALDocuments. However, it would be best to eventually in AssemblyLine core to make sure both
  classes multiple-inherit from a dummy object, Pdfizable (TODO(brycew): make a better name), so there
  can be a more specific object to make generic
---
generic object: ALDocument
code: |
  x.filing_type
  x.filing_description
  x.reference_number
  x.tyler_filing_type 
  x.document_type
  x.motion_type
  x.filing_component
  x.filing_parties
  x.filing_action
  x.optional_services.gather(complete_attribute='complete')
  x.as_pdf()
  x.completed =True
---
generic object: ALDocumentBundle
code: |
  x.filing_type
  x.filing_description
  x.reference_number
  x.tyler_filing_type 
  x.document_type
  x.motion_type
  x.filing_component
  x.filing_parties
  x.filing_action
  x.optional_services.gather(complete_attribute='complete')
  x.as_pdf()
  x.completed =True
---
generic object: DAObject
code: |
  x.tyler_filing_type = filing_type_map.get(x.filing_type,{}).get('code')
---
generic object: DAObject
code: |
  x.document_type = x.document_type_map.get(x.document_type_code,{}).get('code')
---
generic object: DAObject
code: |
  x.filing_component = x.filing_component_map.get(x.filing_component_code,{}).get('code')
---
generic object: DAObject
id: eserve
question: |
  Would you like to e-file this document, serve to the desginated party, or both?
fields:
  - Efile or serve?: x.filing_action
    choices:
      - Efile: efile
      - Efile and Serve: efile_and_serve
      - Serve: serve
---
generic object: DAObject
id: any optional services
question: |
  Optional services - ${ x.title }
subquestion: |
  Do you want to add any optional services for this document?
yesno: x.optional_services.there_are_any
---
generic object: DAObject
code: |
  if not x.optional_service_options:
    x.optional_services.there_are_any = False
---
generic object: DAObject
id: another optional service
question: |
  Are there any other optional services that you want for ${ x.title }?
yesno: x.optional_services.there_is_another
---
generic object: DAObject
code: |
  my_code = x.optional_services[i].code
  if x.optional_service_map.get(my_code,{}).get('multiplier'):
    x.optional_services[i].multiplier
  if x.optional_service_map.get(my_code,{}).get('hasfeeprompt'):
    x.optional_services[i].fee_amount
  x.optional_services[i].complete = True
---
generic object: DAObject
code: |
  raw_opt_servs = proxy_conn.get_optional_services(court_id, x.filing_type).data
  x.optional_service_options, x.optional_service_map = choices_and_map(raw_opt_servs)
  del raw_opt_servs
---
generic object: DAObject
code: |
  raw_components = proxy_conn.get_filing_components(court_id, x.filing_type)
  x.filing_component_options, x.filing_component_map = choices_and_map(raw_components.data)
  del raw_components
---
generic object: DAObject
code: |
  x.motion_type_options, x.motion_type_map = choices_and_map(proxy_conn.get_motion_types(court_id, x.filing_type).data)
---
generic object: DAObject
code: |
  x.document_type_options, x.document_type_map = choices_and_map(proxy_conn.get_document_types(court_id, x.filing_type).data)
---
generic object: DAObject
id: document type
question: |
  Document type - ${ x.title }
subquestion: |
  If a judge has ordered that this case is sealed, select
  "Confidential". You should also attach a copy of the judge's order.
fields:
  - Document type: x.document_type_code
    input type: radio
    code: |
      x.document_type_options
    default: ${ matching_tuple_option('non-confidential', x.document_type_options) }
---
generic object: DAObject
id: filing component
if: |
  not exactly_one_required_filing_component(x.filing_component_options, x.filing_component_map)
question: |
  Filing Component
fields:
  - Filing Component: x.filing_component_code
    datatype: dropdown
    code: |
      x.filing_component_options
---
generic object: DAObject
if: |
  exactly_one_required_filing_component(x.filing_component_options, x.filing_component_map)
code: |
  x.filing_component_code = next(iter(x.filing_component_options))[0]
---
generic object: DAObject
id: motion_type
question: |
  Motion Type
fields:
  - Motion Type: x.motion_type_code
    datatype: dropdown
    code: |
      x.motion_type_options
---
generic object: DAObject
code: |
  if x.motion_type_options:
    x.motion_type = x.motion_type_map.get(x.motion_type_code)
  else:
    x.motion_type = None
---
generic object: DAObject
id: Parties resp for payment
question: |
  Parties responsible for payment
fields: 
  - Parties for payment: x.existing_parties_payment_dict
    datatype: checkboxes
    code: |
      all_case_parties
---
generic object: DAObject
code: |
  if needs_all_info and len(users) == 1:
    x.filing_parties = ['users[0]']
    # explain_user_paying
  else:
    x.filing_parties = list(x.existing_parties_payment_dict.true_values())
---
generic object: DAObject
objects:
  - x.optional_services: DAList.using(object_type=DAObject)
---
generic object: ALExhibitDocument
code: |
  x.title = x.exhibits[0].title
---
code: |
  filing_description_datafield = proxy_conn.get_datafield(court_id, 'FilingFilingDescription').data or {}
---
code: |
  filing_type_options, filing_type_map = choices_and_map(proxy_conn.get_filing_types(court_id, case_category, case_type, is_initial_filing).data)
---
code: |
  if needs_all_info or any([u.is_new for u in users]):
    all_case_parties_tmp = [[user.instanceName, str(user)] for user in users]
  else:
    all_case_parties_tmp = []

  if not needs_all_info:
    all_case_parties_tmp.extend([[party.tyler_id, str(party.name)] for party in found_case.participants])

  all_case_parties = all_case_parties_tmp
  del all_case_parties_tmp
---
code: |
  timing = 'Initial' if is_initial_filing else 'Subsequent'
  case_category_options, case_category_map = choices_and_map(proxy_conn.get_case_categories(court_id, fileable_only=True, timing=timing).data) 
---
code: |
  timing = 'Initial' if is_initial_filing else 'Subsequent'
  case_type_options, case_type_map = choices_and_map(proxy_conn.get_case_types(court_id, case_category, timing=timing).data)
---
code: |
  def exactly_one_required_filing_component(fc_opts, fc_map) -> bool:
    if len(fc_opts) > 1:
      return False
    filing_component_code = next(iter(fc_opts))[0]
    return fc_map.get(filing_component_code,{}).get('required')
---
code: |
  from typing import List, Tuple
  def matching_tuple_option(option:str, options:List[Tuple]):
    return next(filter(lambda type: option in type[1].lower(), options),[None])[0]
---
############ Payments Stuff ############
reconsider:
  - tyler_payment_account_options
id: payment account
question: |
  Payment Account
subquestion: |
  Select an existing account below, or add a payment account
  using the 
  [Admin Interface](${ interview_url(i=user_info().package + ":admin_interview.yml", reset=1) }){:target="_blank"}
  
  Refresh this page when you have finished adding the account.
fields:
  - Payment Account: tyler_payment_id
    datatype: dropdown
    code: |
      tyler_payment_account_options
---
code: |
  allowable_card_types = full_court_info.data.get('allowablecardtypes', [])
  res = proxy_conn.get_payment_account_list().data
  if res:
    tyler_payment_account_options = filter_payment_accounts(res, allowable_card_types)
  else:
    tyler_payment_account_options = []

  res = proxy_conn.get_global_payment_account_list().data
  if res:
    tyler_payment_account_options.extend(filter_payment_accounts(res, allowable_card_types))
---
code: |
  full_court_info = proxy_conn.get_court(court_id)
---