---
modules:
  - .efm_client
  - .conversions
  - .interview_logic
  - docassemble.ALToolbox.misc
---
include:
  - login_qs.yml
---
generic object: EFCaseSearch
objects:
  - x.somebody: ALIndividual
---
generic object: EFCaseSearch
objects:
  - x.found_cases: DAList.using(gathered=True)
---
id: interview order
generic object: EFCaseSearch
comment: |
  Main API of this YAML file. You should only depend on variables declared in this block.
  To account for being able to search for multiple different cases in different courts,
  all of these attributes are in a `EFCaseSearch` object.
need:
  - x.court_id
code: |
  x.can_file_non_indexed_case
  x.do_what_choice
  x.found_case
  if x.found_case and x.do_what_choice == 'docket_lookup':
    x.display_case
  if x.found_case is None and x.can_file_non_indexed_case:
    x.non_indexed_docket_number
  x.case_was_found = x.found_case is not None
---
generic object: EFCaseSearch
code: |
  if x.case_search_task_status.ready():
    if not x.case_search_task_status.failed():
      x.tmp_obj = x.case_search_task_status.get()
      x.cms_connection_issue = x.tmp_obj[0] or None
      x.found_cases = x.tmp_obj[1]
      if x.found_cases is None: # we're okay with empty lists, but not None
        x.found_cases = DAEmpty(x.instanceName + '.found_cases')
    else:
      log(x.case_search_task_status.result().error_message)
      log(str(x.case_search_task_status.result().error_trace))
      log(str(x.case_search_task_status.result().variables))
      x.cms_connection_issue = False
      x.found_cases = DAEmpty(x.instanceName + '.found_cases')
---
only sets:
  - x.found_case
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'party_search'
code: |
  x.somebody.name.first
  if not x.case_search_task_status.ready():
    x.case_search_waiting_screen
  else:
    x.cms_connection_issue
    x.found_cases
    if x.found_cases.gathered and x.found_cases:
      x.found_case = x.case_choice
    else:
      x.warn_no_results
      x.found_case = None
  # undefine('x.somebody', 'x.case_search_task_status',
  #     'x.case_choice', 'x.found_cases')
---
depends on:
  - x.docket_number_from_user
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'docket_lookup'
code: |
  x.docket_number_from_user
  x.docket_case_response
  if not x.docket_case_response.is_ok() or len(x.docket_case_response.data) == 0:
    x.warn_no_results
    x.found_case = None
  else:
    x.court_id
    x.found_case = DAObject(x.instanceName + '.found_case')
    parse_case_info(proxy_conn, x.found_case, x.docket_case_response.data[0], x.court_id, fetch=True, roles=x.party_type_map)
  # undefine('x.docket_number_from_user', 'x.docket_case_response')
---
only sets:
  - x.found_case
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'non_indexed_case'
code: |
  if x.can_file_non_indexed_case:
    x.non_indexed_docket_number
    x.found_case = None 
  else:
    x.no_non_indexed_cases
    x.found_case = None
---
only sets:
  - x.can_file_non_indexed_case
generic object: EFCaseSearch
code: |
  x.court_code_results = proxy_conn.get_court(x.court_id).data
  if x.court_code_results:
    x.can_file_non_indexed_case = x.court_code_results.get('allowfilingintononindexedcase', False)
  else:
    x.can_file_non_indexed_case = False
---
generic object: EFCaseSearch
id: no non-indexed cases
question: |
  ${ x.court_id} does not allow filing into non-indexed cases
continue button field: x.no_non_indexed_cases
---
generic object: EFCaseSearch
id: no cases found
question: |
  No cases found
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online, and the case you are searching for might exist.
  % endif

  % if not x.found_cases.resp_ok:
  Something went wrong with the e-filing system when searching for cases.
  % endif

  % if x.can_file_non_indexed_case:
  You can either continue to file into a non-indexed case or hit "${ word('back') }" to 
  try a new search.
  % else:
  Unfortunately, ${ x.court_id } does not allow filing into non-indexed cases.
  % endif
continue button field: x.warn_no_results
---
generic object: EFCaseSearch
id: case lookup
question: |
  Find your case
subquestion: |
  % if x.can_file_non_indexed_case:
  ${ collapse_template(x.explain_case_search_choices_template) }
  % endif
fields:
  - How do you want to find your case?: x.do_what_choice
    datatype: radio
    code: |
      x.get_lookup_choices(x.can_file_non_indexed_case)
---
generic object: EFCaseSearch
template: x.explain_case_search_choices_template
subject: |
  What is a non-indexed case?
content: |
  Some courts only allow you to search part of the court's
  docket. If that applies to the court you want to file into,
  you can still file but you must use the case number so that
  a clerk can match your filing to the case.
---
generic object: EFCaseSearch
template: x.party_search_choice
content: |
  Party name
---
generic object: EFCaseSearch
template: x.docket_lookup_choice
content: |
  Case number
---
generic object: EFCaseSearch
template: x.non_indexed_choice
content: |
  I want to file into a non-indexed case
---
sets:
  - x.somebody.name.first
generic object: EFCaseSearch
id: party name
question: |
  Party name
subquestion: |
  Enter the name of a party involved in the case.
fields:
  code: |
    x.somebody.name_fields(person_or_business='unknown')
---
generic object: EFCaseSearch
event: x.case_search_waiting_screen
id: case-search-wait
question: |
  <i class="fas fa-cog fa-spin"></i> Your search is in progress <i class="fas fa-cog fa-spin"></i>
subquestion: |
  Please wait.
reload: True
---
need:
  - x.court_id
  - x.party_type_map
generic object: EFCaseSearch
code: |
  x.case_search_task_status = background_action('case_search_task', 'refresh', my_x=x)
---
event: case_search_task
code: |
  my_x = action_argument('my_x')
  background_response(search_case_by_name(proxy_conn=proxy_conn,
      var_name=my_x.instanceName + '.found_cases', court_id=my_x.court_id,
      somebody=my_x.somebody, filter_fn=filter_fn, roles=my_x.party_type_map))
---
generic object: EFCaseSearch
code: |
  x.party_type_map = all_party_type_map
---
id: docket id
generic object: EFCaseSearch
question: |
  ${ str(x.docket_lookup_choice) }
subquestion: |
  ${ collapse_template(x.case_number_format_template) }

fields:
  - ${ str(x.docket_lookup_choice) }: x.docket_number_from_user
---
id: ask non-indexed docket number
generic object: EFCaseSearch
question: |
  Case number
subquestion: |
  Enter the case number for the non-indexed case

  ${ collapse_template(x.case_number_format_template) }

fields:
  - Case number: x.non_indexed_docket_number
# TODO: input validation is not possible--no required format for
# case number in Illinois
---
generic object: EFCaseSearch
code: |
  if x.do_what_choice == 'docket_lookup' and x.found_case is None and x.can_file_non_indexed_case:
    x.non_indexed_docket_number = x.docket_number_from_user
---
generic object: EFCaseSearch
template: x.case_number_format_template
subject: ""
content: ""
---
generic object: EFCaseSearch
if: |
 jurisdiction_id == 'illinois'
template: x.case_number_format_template
subject: |
  How to enter your case number (Except Cook County)
content: |
  Case numbers are usually in the following format: "YYYYxx###": where "YYYY" is the 4 digit year,
  "xx" is are the category letters of your case category, and "###" are the 3 digit sequence number of the case.
  [See more information here](https://odysseyfileandserve.zendesk.com/hc/en-us/articles/360049682351-Illinois-What-is-the-correct-format-for-my-case-number-).
---
generic object: EFCaseSearch
if: |
  jurisdiction_id == 'illinois' and 'cook' in x.court_id
template: x.case_number_format_template
subject: |
  How to enter your case number (Chicago/Cook County only)
content: |
  [See information here](https://www.illinoislegalaid.org/legal-information/e-filing-tips-cook-county).
---
if: |
  x.do_what_choice == 'docket_lookup'
generic object: EFCaseSearch
comment: |
  Long acting action
need:
  - proxy_conn.authed_user_id
depends on:
  - x.docket_number_from_user
code: |
  x.docket_case_response = proxy_conn.get_cases(x.court_id, docket_number=x.docket_number_from_user)
  x.cms_connection_issue = x.docket_case_response.response_code == 203
---
need:
  - x.found_cases
id: results for case search
generic object: EFCaseSearch
comment: |
  Sometimes the date returned for a case search is very wrong (i.e. year 1). We don't display
  it if it's less than year 1000.
question: |
  Case search results
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online. The case information might be out of date.
  % endif

  We found ${ len(x.found_cases) } ${ noun_plural("case", x.found_cases) }
  % if len(x.found_cases) > num_case_choices():
  . Here are ${ x.start_case_idx + 1 } to ${ x.end_case_idx }
  % endif
  :

  ${ action_button_html(url_action(x.instanceName + '.shift_cases_window', direction='prev'), label='Prev') if x.start_case_idx > 0 else '' }
  ${ action_button_html(url_action(x.instanceName + '.shift_cases_window', direction='next'), label='Next') if x.end_case_idx < len(x.found_cases) else ''}
  
  % for case in x.found_cases[x.start_case_idx:x.end_case_idx]:
  * ${ case.title } ${ '(' + case.date + ')' if case.date.year > 1000 else '' }
  % endfor


  ${ collapse_template(x.case_results_template) }

fields:
  - "${ x.case_choice_label }": x.case_choice
    datatype: object 
    object labeler: |
      case_labeler
    choices:
      - x.found_cases[x.start_case_idx:x.end_case_idx]
---
generic object: EFCaseSearch
template: x.case_choice_label
content: |
  Which case?
---
generic object: EFCaseSearch
event: x.shift_cases_window
code: |
  x.start_case_idx, x.end_case_idx = shift_case_select_window(proxy_conn, x.found_cases,
    direction=action_argument('direction'), start_idx=x.start_case_idx, end_idx=x.end_case_idx, roles=x.party_type_map)
---
generic object: EFCaseSearch
code: |
  x.start_case_idx = 0
  x.end_case_idx = min(len(x.found_cases), num_case_choices())
---
template: x.case_results_template
generic object: EFCaseSearch
subject: |
  View case data
content: |
  % for case in x.found_cases[x.start_case_idx:x.end_case_idx]:
  #### ${ case.title } ${ '(' + case.date + ')' if case.date.year > 1000 else '' }
  * Docket ID: ${ case.docket_number }
  * Court ID: ${ case.court_id }
  * Case Category: ${ x.case_category_map.get(case.category, {}).get('name', case.category) }
  % endfor
comment: |
  Can't use this code for court ID without causing an infinite loop? Unclear why
  * Court ID: ${ trial_court_map.get(case.court_id, {}).get('name', case.court_id) }
---
id: display case
generic object: EFCaseSearch
continue button field: x.display_case
question: |
  Your case was found
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online. The case information might be out of date.
  % endif
  
  % if x.found_case:
  #### ${ x.found_case.title} ${ '(' + x.found_case.date + ')' if x.found_case.date.year > 1000 else '' }
  * ${ str(x.docket_lookup_choice) }: ${ x.found_case.docket_number }
  * Court ID: ${ x.found_case.court_id }
  * Case Category: ${ x.case_category_map.get(x.found_case.category, {}).get('name', x.found_case.category) }
  % endif

  ${ collapse_template(x.not_actually_case) }
---
comment: |
  Meant to be overridden to allow authors to control what cases
  are shown as options
code: |
  def filter_fn(new_case):
    return True
---
generic object: EFCaseSearch
template: x.not_actually_case
subject: |
  This isn't my case!
content: |
  If we found the wrong case, you can press the "undo" button to go back and find a different case
---
generic object: EFCaseSearch
code: |
  x.case_category_options, x.case_category_map = choices_and_map(proxy_conn.get_case_categories(x.court_id, fileable_only=False, timing=None).data)
---
#########################################
## Populating Case Parties based on the case search
#########################################
---
need:
  - users
  - is_user_party
  - is_other_party
  - other_parties
  - target_case.found_case
only sets: add_existing_users
code: |
  if target_case.self_in_case not in ['is_self', 'is_filing']:
    users.appendObject()
    users[0].is_new = True
    to_add_participants = target_case.found_case.participants
  else:
    target_case.self_partip_choice.is_new = False
    target_case.self_partip_choice.is_form_filler = target_case.self_in_case == 'is_self'
    # Change where DA thinks this obj came from, so it says "you", and not "NAME"
    users.append(target_case.self_partip_choice.copy_deep('users[0]'))
    to_add_participants = [p for p in target_case.found_case.participants if p.instanceName != target_case.self_partip_choice.instanceName]

  for partip in to_add_participants:
    partip.is_new = False
    if is_user_party(partip):
      users.append(partip.copy_deep(f'users[{len(users.elements)}]'))
    elif is_other_party(partip):
      other_parties.append(partip.copy_deep(f'other_parties[{len(other_parties.elements)}]'))
    else:
      log(f'partip: ${partip} has weird role: ${partip.party_type}')
  add_existing_users = True
---
code: |
  is_defendant_filters = [
    CodeType('20641'),
    'defendant',
    'respondent',
  ]

  is_plaintiff_filters = [
    CodeType('20646'),
    'plaintiff',
    'petitioner',
  ]
---
code: |
  def is_defendant_party(p):
    return any([pred([p.party_type, p.party_type_name]) for pred in make_filters(is_defendant_filters)])
  
  def is_plaintiff_party(p):
    return any([pred([p.party_type, p.party_type_name]) for pred in make_filters(is_plaintiff_filters)])
---
code: |
  if user_ask_role == 'plaintiff':
    is_user_filters = is_plaintiff_filters
    is_other_party_filters = is_defendant_filters
  else:
    is_user_filters = is_defendant_filters
    is_other_party_filters = is_plaintiff_filters
---
if: len(party_type_options) > 1
comment: |
  TODO(brycew): should be attached to the DACaseSearch, but have had problems with lambda attributes
code: |
  if user_ask_role == 'plaintiff':
    is_user_party = is_plaintiff_party
    is_other_party = is_defendant_party
  else:
    is_user_party = is_defendant_party
    is_other_party = is_plaintiff_party
---
if: len(party_type_options) == 1
code: |
  is_user_party = lambda p: True
  is_other_party = lambda p: False
---
id: found-this-participant
generic object: EFCaseSearch
if: len(x.maybe_user_partips) == 1
question: |
  We found this participant in the existing case
subquestion: |
  Are you ${ x.maybe_user_partips[0] }?
fields:
  - no label: x.self_in_case
    datatype: radio
    code: |
      x.self_in_case_choices
---
id: found-these-participants
generic object: EFCaseSearch
if: len(x.maybe_user_partips) > 1
question: |
  We found these participants in the existing case
subquestion: |
  % for partip in x.maybe_user_partips:
  * ${ partip }
  % endfor
  
  Are you any of the above participants?
fields:
  - no label: x.self_in_case
    datatype: radio
    code: |
      x.self_in_case_choices
  - I am: x.self_partip_choice
    datatype: object_radio
    choices: |
      x.maybe_user_partips
    js show if: |
      val("x.self_in_case") == "is_self" || val("x.self_in_case") == "is_filing"
---
generic object: EFCaseSearch
code: |
  x.maybe_user_partips = [partip for partip in x.found_case.participants if is_user_party(partip)]
---
generic object: EFCaseSearch
if: len(x.maybe_user_partips) == 1
code: |
  if x.self_in_case in ['is_self', 'is_filing']:
    x.self_partip_choice = x.maybe_user_partips[0]
---
generic object: EFCaseSearch
if: len(x.maybe_user_partips) == 0
code: |
  x.self_in_case = 'no'
---
generic object: EFCaseSearch
code: |
  if len(x.maybe_user_partips) == 1:
    person_word = word(x.maybe_user_partips[0].name.familiar())
  else:
    person_word = word('one of them')

  if logged_in_user_is_admin:
    x.self_in_case_choices = [
      ['is_filing', word(f'I am filing for { person_word }')]
    ]
  else:
    x.self_in_case_choices = [
      ['is_self', word('Yes')],
      ['is_filing', word(f'No, but I am filing for { person_word }')]
    ]

  x.self_in_case_choices.extend([
    ['no', word('No')],
    ['idk', word("I do not know")]
  ])