---
modules:
  - .efm_client
  - .conversions
  - .interview_logic
  - docassemble.ALToolbox.misc
---
include:
  - login_qs.yml
---
generic object: EFCaseSearch
objects:
  - x.somebody: ALIndividual
---
generic object: EFCaseSearch
objects:
  - x.found_cases: DAList.using(gathered=True)
---
id: interview order
generic object: EFCaseSearch
comment: |
  Main API of this YAML file. You should only depend on variables declared in this block.
  To account for being able to search for multiple different cases in different courts,
  all of these attributes are in a `EFCaseSearch` object.
need:
  - x.court_id
code: |
  x.can_file_non_indexed_case
  x.do_what_choice
  x.found_case
  if x.found_case and x.do_what_choice == 'docket_lookup':
    x.display_case
  if x.found_case is None and x.can_file_non_indexed_case:
    x.non_indexed_docket_number
  x.case_was_found = x.found_case is not None
---
generic object: EFCaseSearch
code: |
  if x.case_search_task_status.ready():
    if not x.case_search_task_status.failed():
      x.tmp_obj = x.case_search_task_status.get()
      x.tmp_dump = json_unwrap(x.tmp_obj)
      x.cms_connection_issue = x.tmp_dump[0] or None
      x.found_cases = x.tmp_dump[1] or DAEmpty(x.instanceName + '.found_cases')
    else:
      log(x.case_search_task_status.result().error_message)
      log(str(x.case_search_task_status.result().error_trace))
      log(str(x.case_search_task_status.result().variables))
      x.cms_connection_issue = False
      x.found_cases = DAEmpty(x.instanceName + '.found_cases')
---
only sets:
  - x.found_case
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'party_search'
code: |
  x.somebody.name.first
  if not x.case_search_task_status.ready():
    x.case_search_waiting_screen
  else:
    x.cms_connection_issue
    x.found_cases
    if x.found_cases.gathered and x.found_cases:
      x.found_case = x.case_choice
    else:
      x.warn_no_results
      x.found_case = None
  undefine('x.somebody', 'x.case_search_task_status',
      'x.case_choice', 'x.found_cases')
---
depends on:
  - x.docket_id_from_user
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'docket_lookup'
code: |
  x.docket_id_from_user
  x.docket_case_response
  if not x.docket_case_response.is_ok() or len(x.docket_case_response.data) == 0:
    x.warn_no_results
    x.found_case = None
  else:
    x.court_id
    x.found_case = DAObject(x.instanceName + '.found_case')
    parse_case_info(proxy_conn, x.found_case, x.docket_case_response.data[0], x.court_id, fetch=True, roles=all_party_type_map)
  undefine('x.docket_id_from_user', 'x.docket_case_response')
---
only sets:
  - x.found_case
generic object: EFCaseSearch
if: |
  x.do_what_choice == 'non_indexed_case'
code: |
  if x.can_file_non_indexed_case:
    x.non_indexed_docket_number
    x.found_case = None 
  else:
    x.no_non_indexed_cases
    x.found_case = None
---
only sets:
  - x.can_file_non_indexed_case
generic object: EFCaseSearch
code: |
  x.court_code_results = proxy_conn.get_court(x.court_id).data
  if x.court_code_results:
    x.can_file_non_indexed_case = x.court_code_results.get('allowfilingintononindexedcase', False)
  else:
    x.can_file_non_indexed_case = False
---
generic object: EFCaseSearch
id: no non-indexed cases
question: |
  ${ x.court_id} does not allow filing into non-indexed cases
continue button field: x.no_non_indexed_cases
---
generic object: EFCaseSearch
id: no cases found
question: |
  No cases found
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online, and the case you are searching for might exist.
  % endif

  % if x.can_file_non_indexed_case:
  You can either continue to file into a non-indexed case or hit "${ word('back') }" to 
  try a new search.
  % else:
  Unfortunately, ${ x.court_id } does not allow filing into non-indexed cases.
  % endif
continue button field: x.warn_no_results
---
generic object: EFCaseSearch
id: case lookup
question: |
  Case lookup
subquestion: |
  % if x.can_file_non_indexed_case:
  ${ collapse_template(explain_case_search_choices_template) }
  % endif
fields:
  - no label: x.do_what_choice
    datatype: radio
    code: |
      get_lookup_choices(x.can_file_non_indexed_case)
---
template: explain_case_search_choices_template
subject: |
  What is a non-indexed case?
content: |
  Some courts only allow you to search part of the court's
  docket. If that applies to the court you want to file into,
  you can still file but you must use the case number so that
  a clerk can match your filing to the case.
---
sets:
  - x.somebody.name.first
generic object: EFCaseSearch
id: party name
question: |
  Party name to find
subquestion: |
  Enter the name of a party involved in the case
fields:
  code: |
    x.somebody.name_fields(person_or_business='unknown')
---
generic object: EFCaseSearch
event: x.case_search_waiting_screen
question: |
  <i class="fas fa-cog fa-spin"></i> Your search is in progress, please wait <i class="fas fa-cog fa-spin"></i>
reload: True
---
need:
  - x.court_id
  - x.party_type_map
generic object: EFCaseSearch
code: |
  x.case_search_task_status = background_action('case_search_task', 'refresh', my_x=x)
---
event: case_search_task
code: |
  my_x = action_argument('my_x')
  background_response(json_wrap(search_case_by_name(proxy_conn=proxy_conn,
      var_name=my_x.instanceName + '.found_cases', court_id=my_x.court_id,
      somebody=my_x.somebody, filter_fn=filter_fn, roles=my_x.party_type_map)))
---
generic object: EFCaseSearch
code: |
  x.party_type_map = all_party_type_map
---
id: docket id
generic object: EFCaseSearch
question: |
  Case number
subquestion: |
  ${ collapse_template(case_number_format_template) }

fields:
  - Case number: x.docket_id_from_user
---
id: ask non-indexed docket number
generic object: EFCaseSearch
question: |
  Case number
subquestion: |
  Enter the case number for the non-indexed case

  ${ collapse_template(case_number_format_template) }
  
fields:
  - Case number: x.non_indexed_docket_number
# TODO: input validation is not possible--no required format for
# case number in Illinois
---
template: case_number_format_template
subject: ""
content: ""
---
if: |
 jurisdiction_id == 'illinois'
template: case_number_format_template
subject: |
  How to enter your case number (Except Cook County)
content: |
  [See information here](https://odysseyfileandserve.zendesk.com/hc/en-us/articles/360049682351-Illinois-What-is-the-correct-format-for-my-case-number-)
---
if: |
  jurisdiction_id == 'illinois' and 'cook' in x.court_id
template: case_number_format_template
subject: |
  How to enter your case number (Chicago/Cook County only)
content: |
  [See information here](https://www.illinoislegalaid.org/legal-information/e-filing-tips-cook-county)
---
if: |
  x.do_what_choice == 'docket_lookup'
generic object: EFCaseSearch
comment: |
  Long acting action
need:
  - proxy_conn.authed_user_id
depends on:
  - x.docket_id_from_user
code: |
  x.docket_case_response = proxy_conn.get_cases(x.court_id, docket_id=x.docket_id_from_user)
  x.cms_connection_issue = x.docket_case_response.response_code == 203
---
need:
  - x.found_cases
depends on:
  - x.found_cases
id: results for case search
generic object: EFCaseSearch
question: |
  Case Search Results
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online. The case information might be out of date.
  % endif

  We found ${ len(x.found_cases) } ${ noun_plural("case", x.found_cases) }
  % if len(x.found_cases) > num_case_choices():
  . Here are ${ x.start_case_idx + 1 } to ${ x.end_case_idx }
  % endif
  :

  ${ action_button_html(url_action('x.shift_cases_window', direction='prev'), label='Prev') if x.start_case_idx > 0 else '' }
  ${ action_button_html(url_action('x.shift_cases_window', direction='next'), label='Next') if x.end_case_idx < len(x.found_cases) else ''}
  
  % for case in x.found_cases[x.start_case_idx:x.end_case_idx]:
  * ${ case.title } (${ case.date })
  % endfor

  ${ collapse_template(x.case_results_template) }

fields:
  - Which case?: x.case_choice
    datatype: object 
    object labeler: |
      lambda case: f"{getattr(case, 'docket_id', '')} {getattr(case, 'title', '')} ({getattr(case, 'date', '')})"
    choices:
      - x.found_cases[x.start_case_idx:x.end_case_idx]
---
generic object: EFCaseSearch
event: x.shift_cases_window
code: |
  x.start_case_idx, x.end_case_idx = shift_case_select_window(proxy_conn, x.found_cases,
    direction=action_argument('direction'), start_idx=x.start_case_idx, end_idx=x.end_case_idx)
---
generic object: EFCaseSearch
code: |
  x.start_case_idx = 0
  x.end_case_idx = min(len(x.found_cases), num_case_choices())
---
template: x.case_results_template
generic object: EFCaseSearch
subject: |
  View case data
content: |
  % for case in x.found_cases[x.start_case_idx:x.end_case_idx]:
  #### ${ case.title } (${ case.date })
  * DocketID: ${ case.docket_id }
  * CourtID: ${ case.court_id }
  * CaseCategory: ${ case.category }
  % endfor
---
id: display case
generic object: EFCaseSearch
continue button field: x.display_case
question: |
  Your case was found
subquestion: |
  % if x.cms_connection_issue:
  The court's case management system isn't online. The case information might be out of date.
  % endif
  
  % if x.found_case:
  #### ${ x.found_case.title} (${ x.found_case.date })
  * DocketID: ${ x.found_case.docket_id }
  * CourtID: ${ x.found_case.court_id }
  * CaseCategory: ${ x.found_case.category }
  % endif
---
comment: |
  Meant to be overridden to allow authors to control what cases
  are shown as options
code: |
  def filter_fn(new_case):
    return True
---
#########################################
## Populating Case Parties based on the case search
#########################################
---
need:
  - users
  - is_user_party
  - is_other_party
  - other_parties
  - target_case.found_case
code: |
  if not target_case.self_in_case:
    users.appendObject()
    users[0].is_new = True
    to_add_participants = target_case.found_case.participants
  else:
    target_case.self_partip_choice.is_new = False
    # Change where DA thinks this obj came from, so it says "you", and not "NAME"
    users.append(target_case.self_partip_choice.copy_deep('users[0]'))
    to_add_participants = [p for p in target_case.found_case.participants if p.instanceName != target_case.self_partip_choice.instanceName]

  for partip in to_add_participants:
    partip.is_new = False
    if is_user_party(partip):
      users.append(partip.copy_deep(f'users[{len(users.elements)}]'))
    elif is_other_party(partip):
      other_parties.append(partip.copy_deep(f'other_parties[{len(other_parties.elements)}]'))
    else:
      log(f'partip: ${partip} has weird role: ${partip.party_type}')
  add_existing_users = True
---
comment: |
  TODO(brycew): should be attached to the DACaseSearch, but have had problems with lambda attributes
only sets:
  - is_user_party
  - is_other_party
code: |
  def is_defendant_party(p):
    return p.party_type == '20641' or \
        (p.party_type_name is not None and 'defendant' in p.party_type_name.lower())
  
  def is_plaintiff_party(p):
    return p.party_type == '20646' or \
        (p.party_type_name is not None and 'plaintiff' in p.party_type_name.lower())
  
  if user_ask_role == 'plaintiff':
    is_user_party = is_plaintiff_party
    is_other_party = is_defendant_party
  else:
    is_user_party = is_defendant_party
    is_other_party = is_plaintiff_party
---
generic object: EFCaseSearch
question: |
  % if len(x.maybe_user_partips) == 1:
  We found this participant in the existing case
  % else:
  We found these participants in the existing case
  % endif
subquestion: |
  % if len(x.maybe_user_partips) == 1:
  Are you ${ x.maybe_user_partips[0] }?
  % elif len(x.maybe_user_partips) > 1:
  % for partip in x.maybe_user_partips:
  * ${ partip }
  % endfor
  
  Are you any of the above participants?
  % endif
fields:
  - no label: x.self_in_case
    datatype: yesnomaybe
  - I am: x.self_partip_choice
    datatype: object_radio
    choices: |
      x.maybe_user_partips
    show if: x.self_in_case
---
generic object: EFCaseSearch
code: |
  x.maybe_user_partips = [partip for partip in x.found_case.participants if is_user_party(partip)]