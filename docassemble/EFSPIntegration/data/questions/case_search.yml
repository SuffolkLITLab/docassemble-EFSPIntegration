---
modules:
  - .efm_client
---
include:
  - login_qs.yml
---
objects: 
  - found_cases: DAList.using(object_type=DAObject, auto_gather=False)  
---
#mandatory: True
id: interview order
code: |
  do_what_choice
  if do_what_choice == 'search':
    somebody.name.first
    court_id    
    if not case_search_task_status.ready():
      case_search_waiting_screen
    else:
      if case_tracking_choice is None:
        warn_no_results
        case_tracking_id
      else:      
        case_tracking_id = case_tracking_choice
        found_case = next(filter(lambda case: case.tracking_id == case_tracking_id, found_cases))
  elif do_what_choice == 'lookup':
    case_docket_id
    court_id    
    get_case_response
    # display_case
    found_case = get_case_response.data
    case_tracking_id = get_case_response.data.get('value',{}).get('caseTrackingID',{}).get('value')
  else:
    case_tracking_id
    while not confirm_case_tracking_id:
      del case_tracking_id
      case_tracking_id
  interview_order_find_case = True      
---
id: no cases found
question: |
  No cases found
subquestion: |
  You can either enter a case tracking ID or hit "back" to 
  try a new search.
continue button field: warn_no_results
---
id: case lookup
question: |
  Case lookup
field: do_what_choice
choices:
  - Find a case by party name: search
  - Find a case by Docket Number: lookup
  - I know the tracking ID of the case: tracking_id
---
objects:
  - somebody: Individual
---
id: tracking id
question: |
  Enter the case tracking ID
fields:
  - Case Tracking ID: case_tracking_id
---
question: |
  Is this the case you were trying to find?
subquestion: |
  
yesno: confirm_case_tracking_id
---
id: party name
question: |
  Party name to find
subquestion: |
  Enter the name of a party involved in the case
fields:
  - First: somebody.name.first
  - Middle: somebody.name.middle
    required: False
  - Last: somebody.name.last
  - Suffix: somebody.name.suffix
    required: False
    code: |
      name_suffix()
---
id: court
question: |
  Choose a court
fields:
  - no label: trial_court
    code: |
      all_courts
---
id: debug courts
question:  |
  ${ all_courts }
field: _cont
---
code: |
  all_courts = proxy_conn.get_courts().data
---
event: case_search_waiting_screen
question: |
  Your search is in progress, please wait
---
code: |
  case_search_task_status = background_action('case_search_task', 'refresh')
---
event: case_search_task
code: |
  background_response_action('case_search_done', case_response = proxy_conn.get_cases(court_id, {"first": somebody.name.first, "last":somebody.name.last}, None))
---
event: case_search_done
code: |
  get_cases_response = action_argument('case_response')
  background_response()
---
id: docket id
question: |
  Docket ID
fields:
  - Docket id: case_docket_id
---
need:
  - proxy_conn.authed_user_id
code: |
  get_case_response = proxy_conn.get_case(court_id, case_docket_id)
---
id: results
question: |
  Results
subquestion: |
  ${ collapse_template(case_results_template) }
fields:
  - Which case?: case_tracking_choice
    datatype: dropdown
    code: |
      found_case_options
---
template: case_results_template
subject: |
  View case data
content: |
  % for case in found_cases:
  #### ${ case.title } (${ case.date })
  * DocketID: ${ case.docket_id }
  * CourtID: ${ case.court_id }
  * TrackingID: ${ case.tracking_id }
  * CaseCategory: ${ case.category }  
  % endfor  
---
id: display case
continue button field: display_case
question: |
  Results
subquestion: |
  ```
  ${ json.dumps(get_case_response.data) } 
  ```
---
need:
  - court_id
  - somebody.name.first
  - found_cases
id: get cleaned up results
code: |
    found_cases.clear()

    from datetime import datetime
    #try: # trap name errors, etc. so Docassemble will only run this code once
    first_pass = get_cases_response = proxy_conn.get_cases(court_id, {"first": somebody.name.first, "last":somebody.name.last})
    if first_pass.is_ok():
      for entry in first_pass.data:
        new_case = found_cases.appendObject()
        new_case.details = entry
        new_case.court_id = court_id
        new_case.tracking_id =  entry.get('value',{}).get('caseTrackingID',{}).get('value')
        new_case.docket_id = entry.get('value',{}).get('caseDocketID',{}).get('value')
        new_case.category = entry.get('value',{}).get('caseCategoryText',{}).get('value')
       
        new_case.case_details = proxy_conn.get_case(court_id, new_case.tracking_id).data
        # TODO: is the order of this array predictable? might it break if Tyler changes something?        
        new_case.case_type = new_case.case_details.get('value').get('rest',[{},{}])[1].get('value',{}).get('caseTypeText',{}).get('value')
        new_case.title = new_case.case_details.get('value',{}).get('caseTitleText',{}).get('value')        
        new_case.date = as_datetime(datetime.utcfromtimestamp(new_case.case_details.get('value',{}).get('activityDateRepresentation',{}).get('value',{}).get('dateRepresentation',{}).get('value',{}).get('value',1000)/1000))
        
    # except:
    #  message("Something went wrong")
    
    found_cases.gathered = True
    found_case_options = [{case.tracking_id: f"{case.docket_id} {case.title} ({case.date})"} for case in found_cases]
